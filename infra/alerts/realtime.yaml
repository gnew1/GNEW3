groups: - name: realtime-slo 
  rules: 
  - alert: RealtimeP95High 
    expr: histogram_quantile(0.95, 
sum(rate(rt_broadcast_latency_seconds_bucket[5m])) by (le)) > 0.3 
    for: 5m 
    labels: { severity: critical } 
    annotations: 
      summary: "P95 de broadcast supera 300ms" 
      description: "Verifica NATS, presión de colas 
(rt_dropped_messages_total) y uso de CPU." 
  - alert: RealtimeDrops 
    expr: rate(rt_dropped_messages_total[5m]) > 1 
    for: 3m 
    labels: { severity: warning } 
    annotations: 
      summary: "Backpressure alto en realtime" 
 
 
Notas de integración (resumen) 
● Publica eventos de gobernanza/economía en NATS con publishWithTrace(js, 
'gov.events', Buffer.from(JSON.stringify({...}))). El gateway/servicios 
existentes pueden hacerlo al confirmar propuestas, votos, precios, etc. 
 
● Frontend consume vía LiveEvents / useRealtime y respeta presencia. 
 
● Backpressure: cada conexión mantiene una cola limitada (MAX_QUEUE, shedding de 
antiguos). Si la conexión no drena, se observan drops en 
rt_dropped_messages_total. 
 
● DoD: Panel “Realtime” muestra p95 < 0.300 s en ventana de 5m bajo carga nominal. 
 
Tú dijiste: 
programa a nivel de detalle y entrega para GNEW N82 9.2 APIs y SDKs open source (Prompt 
82) Objetivo: SDK TS/Python/Go + REST/GraphQL versionadas. Roles: Backend, SDK Team, 
Seguridad. Entregables: Paquetes NPM/PyPI/Go, OpenAPI, ejemplos. DoD: SemVer, tests 
contrato, rate limits. 
ChatGPT Plus 
Pensó durante 1m 32s 
Ruta completa: .\services\gateway\main.py 
import os 
import asyncio 
from datetime import datetime 
from typing import List, Optional 
from fastapi import FastAPI, Depends, HTTPException, Header, Request 
from fastapi.responses import JSONResponse 
from fastapi.middleware.cors import CORSMiddleware 
from pydantic import BaseModel, Field 
from sqlalchemy import create_engine, Column, Integer, String, 
DateTime, Text 
from sqlalchemy.orm import sessionmaker, declarative_base, Session as 
OrmSession 
from starlette.middleware import Middleware 
from services.common.middleware import LoggingMiddleware, 
ExceptionMiddleware 
from services.common.health import health_response 
from services.common.otel import setup_otel 
from packages.auth_client import verify as _verify 
from .ratelimit import RateLimit, RateLimitExceeded 
from .versioning import api_version_header 
# ---------- Settings ---------- 
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./gateway.db") 
API_VERSION = os.getenv("API_VERSION", "1.0.0") 
SERVICE_NAME = "gateway" 
DEFAULT_LIMITS = { 
"user": {"minute": 60, "hour": 1200}, 
"admin": {"minute": 300, "hour": 6000}, 
} 
# ---------- App ---------- 
middleware = [ 
Middleware(LoggingMiddleware), 
Middleware(ExceptionMiddleware), 
Middleware( 
CORSMiddleware, 
allow_origins=["*"], 
allow_methods=["*"], 
        allow_headers=["*"], 
        
expose_headers=["X-RateLimit-Limit","X-RateLimit-Remaining","Retry-Aft
 er","X-API-Version"], 
    ), 
] 
app = FastAPI( 
    title="GNEW Gateway API", 
    version=API_VERSION, 
    middleware=middleware, 
    docs_url="/v1/docs", 
    openapi_url="/v1/openapi.json", 
) 
setup_otel(SERVICE_NAME, app) 
 
# ---------- DB ---------- 
engine = create_engine( 
    DATABASE_URL, 
    connect_args={"check_same_thread": False} if 
DATABASE_URL.startswith("sqlite") else {}, 
) 
SessionLocal = sessionmaker(bind=engine, autoflush=False, 
autocommit=False) 
Base = declarative_base() 
 
 
class Proposal(Base): 
    __tablename__ = "proposals" 
    id = Column(Integer, primary_key=True) 
    title = Column(String(160), nullable=False) 
    content = Column(Text, nullable=False) 
    author = Column(String(128), nullable=False) 
    status = Column(String(32), default="draft") 
    created_at = Column(DateTime, default=datetime.utcnow) 
    updated_at = Column(DateTime, default=datetime.utcnow) 
 
 
Base.metadata.create_all(bind=engine) 
 
# ---------- Schemas ---------- 
class ProposalCreate(BaseModel): 
    title: str = Field(min_length=3, max_length=160) 
    content: str = Field(min_length=1) 
    author: str = Field(min_length=2, max_length=128) 
 
 
class ProposalOut(BaseModel): 
    id: int 
    title: str 
    content: str 
    author: str 
    status: str 
    created_at: datetime 
    updated_at: datetime 
 
 
class ProposalsPage(BaseModel): 
    items: List[ProposalOut] 
    next_cursor: Optional[str] = None 
 
 
# ---------- Auth ---------- 
async def get_current_user(authorization=Depends(_verify)): 
    return authorization 
 
 
# ---------- Rate limit ---------- 
rl = RateLimit(limits_by_role=DEFAULT_LIMITS) 
 
 
@app.middleware("http") 
async def rate_limit_guard(request: Request, call_next): 
    # role will be filled later by dependency (we don't have it yet 
here), 
    # so we try to parse JWT lazily using the same header FastAPI will 
use. 
    auth_header = request.headers.get("authorization", "") 
    role = "user" 
    sub = "anonymous" 
    if auth_header.startswith("Bearer "): 
        try: 
            payload = await _verify(authorization=type("C", (), 
{"credentials": auth_header.split()[1]})()) 
            role = payload.get("role", "user") 
            sub = payload.get("sub", "anonymous") 
        except Exception: 
            # unauthenticated users share a tiny pool 
            role = "user" 
            sub = request.client.host if request.client else "ip" 
    key = f"{role}:{sub}:{request.url.path}" 
    try: 
        remaining, reset_in, limit = await rl.check(key, role) 
    except RateLimitExceeded as exc: 
        headers = { 
            "Retry-After": str(int(exc.reset_in)), 
            "X-RateLimit-Limit": str(exc.limit), 
            "X-RateLimit-Remaining": "0", 
            "X-API-Version": API_VERSION, 
        } 
        return JSONResponse(status_code=429, content={"error": 
{"code": "RATE_LIMIT", "message": "Too Many Requests"}}, 
headers=headers) 
    response = await call_next(request) 
    response.headers["X-RateLimit-Limit"] = str(limit) 
    response.headers["X-RateLimit-Remaining"] = str(max(0, remaining)) 
    response.headers["Retry-After"] = str(int(reset_in)) 
    response.headers["X-API-Version"] = API_VERSION 
    return response 
 
 
# ---------- Helpers ---------- 
def db() -> OrmSession: 
    session = SessionLocal() 
    try: 
        yield session 
    finally: 
        session.close() 
 
 
# ---------- REST v1 ---------- 
@app.get("/v1/health") 
async def health(): 
    # basic health; DB ok? 
    try: 
        with engine.connect() as conn: 
            conn.execute("SELECT 1") 
        deps = {"db": "ok", "nats": "ok", "vault": "ok"} 
        return health_response(deps) 
    except Exception: 
        return health_response({"db": "fail", "nats": "ok", "vault": 
"ok"}) 
 
@app.get("/v1/version") 
def version(): 
    return {"api": API_VERSION, "semver": API_VERSION} 
 
@app.get("/v1/proposals", response_model=ProposalsPage) 
def list_proposals(limit: int = 20, cursor: Optional[int] = None, 
session: OrmSession = Depends(db), x_api_version: str = Header(None)): 
    api_version_header(x_api_version, expected=API_VERSION) 
    q = session.query(Proposal).order_by(Proposal.id.desc()) 
    if cursor: 
        q = q.filter(Proposal.id < cursor) 
    rows = q.limit(min(max(limit, 1), 100)).all() 
    next_cursor = rows[-1].id if rows else None 
    return {"items": [ProposalOut(**r.__dict__) for r in rows], 
"next_cursor": next_cursor} 
 
@app.post("/v1/proposals", response_model=ProposalOut) 
def create_proposal(payload: ProposalCreate, session: OrmSession = 
Depends(db), user=Depends(get_current_user), x_api_version: str = 
Header(None)): 
    api_version_header(x_api_version, expected=API_VERSION) 
    row = Proposal(title=payload.title, content=payload.content, 
author=payload.author, status="submitted") 
    session.add(row) 
    session.commit() 
    session.refresh(row) 
    return ProposalOut(**row.__dict__) 
 
@app.get("/v1/proposals/{pid}", response_model=ProposalOut) 
def get_proposal(pid: int, session: OrmSession = Depends(db), 
x_api_version: str = Header(None)): 
    api_version_header(x_api_version, expected=API_VERSION) 
    row = session.get(Proposal, pid) 
    if not row: 
        raise HTTPException(status_code=404, detail="not found") 
    return ProposalOut(**row.__dict__) 
 
Ruta completa: .\services\gateway\ratelimit.py 
import os 
import time 
import asyncio 
from typing import Dict 
 
try: 
    # Redis optional; fallback to in-memory 
    from redis.asyncio import Redis 
except Exception: 
    Redis = None  # type: ignore 
 
 
class RateLimitExceeded(Exception): 
    def __init__(self, reset_in: float, limit: int): 
        self.reset_in = reset_in 
        self.limit = limit 
        super().__init__("limit exceeded") 
 
 
class RateLimit: 
    """Token-bucket per key and per window (minute + hour).""" 
    def __init__(self, limits_by_role: Dict[str, Dict[str, int]]): 
        self.limits = limits_by_role 
        url = os.getenv("REDIS_URL") 
        self.redis: Redis | None = Redis.from_url(url) if (Redis and 
url) else None 
        self._mem: Dict[str, Dict[str, int]] = {} 
 
    async def _incr(self, key: str, window: int, ttl: int) -> int: 
        # prefer redis 
        if self.redis: 
            now = int(time.time()) 
            bucket_key = f"rl:{window}:{key}:{now // ttl}" 
            val = await self.redis.incr(bucket_key) 
            if val == 1: 
                await self.redis.expire(bucket_key, ttl) 
            return int(val) 
        # fallback memory (best-effort for dev) 
        bucket_key = f"{window}:{key}:{int(time.time()) // ttl}" 
        self._mem.setdefault(bucket_key, {"v": 0, "t": 
int(time.time()) + ttl}) 
        self._mem[bucket_key]["v"] += 1 
        # cleanup 
        for k, v in list(self._mem.items()): 
            if v["t"] < time.time(): 
                self._mem.pop(k, None) 
        return self._mem[bucket_key]["v"] 
 
    async def check(self, key: str, role: str) -> tuple[int, float, 
int]: 
        cfg = self.limits.get(role) or self.limits["user"] 
        # minute 
        used_min = await self._incr(key, 60, 60) 
        if used_min > cfg["minute"]: 
            reset = 60 - (time.time() % 60) 
            raise RateLimitExceeded(reset_in=reset, 
limit=cfg["minute"]) 
        # hour 
        used_hour = await self._incr(key, 3600, 3600) 
        if used_hour > cfg["hour"]: 
            reset = 3600 - (time.time() % 3600) 
            raise RateLimitExceeded(reset_in=reset, limit=cfg["hour"]) 
        remaining = min(cfg["minute"] - used_min, cfg["hour"] - 
used_hour) 
        return remaining, 60 - (time.time() % 60), cfg["minute"] 
 
Ruta completa: .\services\gateway\versioning.py 
from fastapi import HTTPException 
 
def api_version_header(header_value: str | None, expected: str): 
    """Require clients to send X-API-Version header compatible with 
SemVer MAJOR.""" 
    if not header_value: 
        return  # allow soft rollout 
    try: 
        client_major = int(header_value.split(".")[0]) 
        server_major = int(expected.split(".")[0]) 
    except Exception: 
        raise HTTPException(status_code=400, detail="invalid 
X-API-Version") 
    if client_major != server_major: 
        raise HTTPException(status_code=426, detail="upgrade 
required") 
 
Ruta completa: .\services\gateway\requirements.in 
fastapi 
uvicorn[standard] 
sqlalchemy 
redis 
pydantic 
python-jose[cryptography] 
structlog 
opentelemetry-api 
strawberry-graphql 
Ruta completa: .\services\gateway\requirements.txt 
# compiled via pip-compile; minimal pinned example 
fastapi==0.115.14 
uvicorn[standard]==0.35.0 
sqlalchemy==2.0.41 
redis==5.2.1 
pydantic==2.11.7 
python-jose[cryptography]==3.5.0 
structlog==25.4.0 
opentelemetry-api==1.34.1 
strawberry-graphql==0.246.1 
Ruta completa: .\services\gateway\graphql.py 
import strawberry 
from strawberry.fastapi import GraphQLRouter 
from typing import List 
from datetime import datetime 
from sqlalchemy.orm import Session as OrmSession 
from fastapi import Depends, HTTPException 
from .main import Proposal, SessionLocal, ProposalOut, ProposalCreate, 
get_current_user, api_version_header 
def db(): 
s = SessionLocal() 
try: 
yield s 
finally: 
s.close() 
@strawberry.type 
class ProposalGQL: 
id: int 
    title: str 
    content: str 
    author: str 
    status: str 
    created_at: datetime 
    updated_at: datetime 
 
@strawberry.type 
class Query: 
    @strawberry.field 
    def proposals(self, info, limit: int = 20) -> List[ProposalGQL]: 
        session: OrmSession = next(db()) 
        rows = 
session.query(Proposal).order_by(Proposal.id.desc()).limit(min(max(lim
 it,1),100)).all() 
        return [ProposalGQL(**r.__dict__) for r in rows] 
 
@strawberry.type 
class Mutation: 
    @strawberry.mutation 
    def create_proposal(self, info, title: str, content: str, author: 
str) -> ProposalGQL: 
        # auth via dependency-like call 
        _ = info.context["user"] 
        session: OrmSession = next(db()) 
        row = Proposal(title=title, content=content, author=author, 
status="submitted") 
        session.add(row) 
        session.commit() 
        session.refresh(row) 
        return ProposalGQL(**row.__dict__) 
 
schema = strawberry.Schema(query=Query, mutation=Mutation) 
router = GraphQLRouter(schema, path="/v1/graphql", 
context_getter=lambda req: {"user": req.state.user if 
hasattr(req.state, "user") else None}) 
 
Ruta completa: .\services\gateway\openapi\openapi.yaml 
openapi: 3.0.3 
info: 
  title: GNEW Gateway API 
  version: 1.0.0 
servers: 
  - url: https://api.gnew.dev/v1 
paths: 
  /health: 
    get: 
      summary: Health 
      responses: 
        '200': 
          description: OK 
  /version: 
    get: 
      summary: API version 
      responses: 
        '200': 
          description: OK 
          content: 
            application/json: 
              schema: 
                type: object 
                properties: 
                  api: { type: string } 
                  semver: { type: string } 
  /proposals: 
    get: 
      summary: List proposals 
      parameters: 
        - in: query 
          name: limit 
          schema: { type: integer, minimum: 1, maximum: 100, default: 
20 } 
        - in: query 
          name: cursor 
          schema: { type: integer } 
        - in: header 
          name: X-API-Version 
          schema: { type: string } 
      responses: 
        '200': 
          description: A page of proposals 
          headers: 
            X-RateLimit-Limit: { schema: { type: integer } } 
            X-RateLimit-Remaining: { schema: { type: integer } } 
            Retry-After: { schema: { type: string } } 
          content: 
            application/json: 
              schema: 
                type: object 
                properties: 
                  items: 
                    type: array 
                    items: 
                      $ref: '#/components/schemas/Proposal' 
                  next_cursor: { type: integer, nullable: true } 
    post: 
      summary: Create proposal 
      security: 
        - bearerAuth: [] 
      parameters: 
        - in: header 
          name: X-API-Version 
          schema: { type: string } 
      requestBody: 
        required: true 
        content: 
          application/json: 
            schema: 
              $ref: '#/components/schemas/ProposalCreate' 
      responses: 
        '200': 
          description: Created 
          content: 
            application/json: 
              schema: 
                $ref: '#/components/schemas/Proposal' 
        '401': 
          description: Unauthorized 
  /proposals/{pid}: 
    get: 
      summary: Get proposal by id 
      parameters: 
        - in: path 
          name: pid 
          required: true 
          schema: { type: integer } 
        - in: header 
          name: X-API-Version 
          schema: { type: string } 
      responses: 
        '200': 
          description: Proposal 
          content: 
            application/json: 
              schema: 
                $ref: '#/components/schemas/Proposal' 
        '404': 
          description: Not found 
components: 
  schemas: 
    Proposal: 
      type: object 
      properties: 
        id: { type: integer } 
        title: { type: string } 
        content: { type: string } 
        author: { type: string } 
        status: { type: string } 
        created_at: { type: string, format: date-time } 
        updated_at: { type: string, format: date-time } 
    ProposalCreate: 
      type: object 
      required: [title, content, author] 
      properties: 
        title: { type: string, minLength: 3, maxLength: 160 } 
        content: { type: string, minLength: 1 } 
        author: { type: string, minLength: 2, maxLength: 128 } 
  securitySchemes: 
    bearerAuth: 
      type: http 
      scheme: bearer 
      bearerFormat: JWT 
 
Ruta completa: .\packages\sdk-client\package.json 
{ 
  "name": "@repo/sdk-client", 
  "version": "1.0.0", 
  "type": "module", 
  "main": "dist/index.js", 
  "types": "dist/index.d.ts", 
  "exports": { 
    ".": "./dist/index.js" 
  }, 
  "scripts": { 
    "build": "tsc", 
    "test": "vitest run", 
    "lint": "eslint . --max-warnings=0", 
    "release": "npm version patch && npm publish --access public" 
  }, 
  "dependencies": { 
    "undici": "^6.19.8" 
  }, 
  "devDependencies": { 
    "@repo/eslint-config": "workspace:*", 
    "@repo/typescript-config": "workspace:*", 
    "@types/node": "^22.15.3", 
    "typescript": "5.8.2", 
    "vitest": "^1.4.0" 
  }, 
  "license": "Apache-2.0" 
} 
 
Ruta completa: .\packages\sdk-client\tsconfig.json 
{ 
  "extends": "@repo/typescript-config/base.json", 
  "compilerOptions": { 
    "outDir": "dist", 
    "declaration": true 
  }, 
  "include": ["src"] 
} 
 
Ruta completa: .\packages\sdk-client\src\index.ts 
/* eslint-disable @typescript-eslint/no-explicit-any */ 
import { setTimeout as sleep } from 'timers/promises'; 
 
export interface SDKOptions { 
  baseUrl?: string;              // e.g. https://api.gnew.dev 
  token?: string;                // Bearer token 
  apiVersion?: string;           // X-API-Version header value 
  retries?: number;              // retry on 429/5xx 
  backoffMs?: number;            // base backoff 
} 
 
export interface ProposalCreate { 
  title: string; 
  content: string; 
  author: string; 
} 
 
export interface Proposal { 
  id: number; 
  title: string; 
  content: string; 
  author: string; 
  status: string; 
  created_at: string; 
  updated_at: string; 
} 
 
export class GnewClient { 
  private base: string; 
  private token?: string; 
  private apiVersion: string; 
  private retries: number; 
  private backoffMs: number; 
 
  constructor(opts: SDKOptions = {}) { 
    this.base = (opts.baseUrl || 'http://gateway:8000') + '/v1'; 
    this.token = opts.token; 
    this.apiVersion = opts.apiVersion || '1.0.0'; 
    this.retries = opts.retries ?? 3; 
    this.backoffMs = opts.backoffMs ?? 250; 
  } 
 
  setToken(token: string) { this.token = token; } 
 
  private async request(path: string, init: RequestInit = {}): 
Promise<any> { 
    const url = this.base + path; 
    let attempt = 0; 
    let lastErr: any; 
    const headers: Record<string, string> = { 
      'Content-Type': 'application/json', 
      'X-API-Version': this.apiVersion 
    }; 
    if (this.token) headers['Authorization'] = `Bearer ${this.token}`; 
 
    while (attempt <= this.retries) { 
      const res = await fetch(url, { ...init, headers: { ...headers, 
...(init.headers as any) } }); 
      if (res.ok) { 
        const ct = res.headers.get('content-type') || ''; 
        return ct.includes('json') ? res.json() : res.text(); 
      } 
      if (res.status === 429 || res.status >= 500) { 
        const retryAfter = Number(res.headers.get('retry-after') || 
0); 
        const backoff = Math.max(retryAfter * 1000, this.backoffMs * 2 
** attempt); 
        await sleep(backoff); 
        attempt += 1; 
        lastErr = new Error(`HTTP_${res.status}`); 
        continue; 
      } 
      const body = await res.text(); 
      throw new Error(`HTTP_${res.status}:${body}`); 
    } 
    throw lastErr || new Error('Request failed'); 
  } 
 
  // REST 
  async listProposals(limit = 20, cursor?: number) { 
    const qs = new URLSearchParams({ limit: String(limit), ...(cursor 
? { cursor: String(cursor) } : {}) }); 
    return this.request(`/proposals?${qs.toString()}`) as Promise<{ 
items: Proposal[]; next_cursor?: number }>; 
  } 
  async createProposal(data: ProposalCreate) { 
    return this.request('/proposals', { method: 'POST', body: 
JSON.stringify(data) }) as Promise<Proposal>; 
  } 
  async getProposal(id: number) { 
    return this.request(`/proposals/${id}`) as Promise<Proposal>; 
  } 
 
  // GraphQL 
  async gql<T = any>(query: string, variables?: Record<string, any>): 
Promise<T> { 
    return this.request('/graphql', { 
      method: 'POST', 
body: JSON.stringify({ query, variables }), 
}) as Promise<T>; 
} 
} 
Ruta completa: .\packages\gnew_sdk\pyproject.toml 
[project] 
name = "gnew-sdk" 
version = "1.0.0" 
description = "Python SDK for GNEW API (REST/GraphQL)" 
authors = [{ name = "GNEW", email = "dev@gnew.dev" }] 
readme = "README.md" 
requires-python = ">=3.10" 
license = { text = "Apache-2.0" } 
dependencies = ["httpx>=0.28", "pydantic>=2.6"] 
[project.urls] 
Homepage = "https://github.com/gnewhq/gnew" 
[tool.setuptools] 
packages = ["gnew_sdk"] 
Ruta completa: .\packages\gnew_sdk\gnew_sdk_init_.py 
from .client import GnewClient 
__all__ = ["GnewClient"] 
Ruta completa: .\packages\gnew_sdk\gnew_sdk\client.py 
from __future__ import annotations 
import asyncio 
import json 
from typing import Any, Dict, Optional 
import httpx 
class GnewClient: 
    def __init__(self, base_url: str = "http://gateway:8000/v1", 
token: str | None = None, api_version: str = "1.0.0", retries: int = 
3, backoff_ms: int = 250) -> None: 
        self.base = base_url.rstrip("/") 
        self.token = token 
        self.api_version = api_version 
        self.retries = retries 
        self.backoff_ms = backoff_ms 
 
    def set_token(self, token: str) -> None: 
        self.token = token 
 
    async def _request(self, method: str, path: str, json_body: 
Optional[dict] = None) -> Any: 
        url = f"{self.base}{path}" 
        attempt = 0 
        headers = {"X-API-Version": self.api_version, "Content-Type": 
"application/json"} 
        if self.token: 
            headers["Authorization"] = f"Bearer {self.token}" 
        async with httpx.AsyncClient(timeout=10) as client: 
            while attempt <= self.retries: 
                resp = await client.request(method, url, 
headers=headers, json=json_body) 
                if resp.status_code < 400: 
                    if "application/json" in 
resp.headers.get("content-type", ""): 
                        return resp.json() 
                    return resp.text 
                if resp.status_code == 429 or resp.status_code >= 500: 
                    retry_after = 
float(resp.headers.get("retry-after", "0")) 
                    backoff = max(retry_after, (self.backoff_ms / 
1000) * (2**attempt)) 
                    await asyncio.sleep(backoff) 
                    attempt += 1 
                    continue 
                raise httpx.HTTPStatusError(f"{resp.status_code} 
{resp.text}", request=resp.request, response=resp) 
        raise RuntimeError("request failed") 
 
    # REST 
    async def list_proposals(self, limit: int = 20, cursor: 
Optional[int] = None) -> Dict[str, Any]: 
        qs = f"?limit={limit}" + (f"&cursor={cursor}" if cursor else 
"") 
        return await self._request("GET", f"/proposals{qs}") 
 
    async def create_proposal(self, title: str, content: str, author: 
str) -> Dict[str, Any]: 
        return await self._request("POST", "/proposals", {"title": 
title, "content": content, "author": author}) 
 
    async def get_proposal(self, pid: int) -> Dict[str, Any]: 
        return await self._request("GET", f"/proposals/{pid}") 
 
    # GraphQL 
    async def gql(self, query: str, variables: Optional[dict] = None) -> Any: 
        return await self._request("POST", "/graphql", {"query": 
query, "variables": variables or {}}) 
 
Ruta completa: .\packages\gnew_sdk\README.md 
# gnew-sdk (Python) 
 
```python 
import asyncio 
from gnew_sdk import GnewClient 
 
async def main(): 
  client = GnewClient("https://api.gnew.dev/v1", api_version="1.0.0") 
  client.set_token("YOUR_JWT") 
  created = await client.create_proposal("Title", "Content", "alice") 
  page = await client.list_proposals(limit=10) 
one = await client.get_proposal(created["id"]) 
gql = await client.gql("query { proposals { id title } }") 
print(page, one, gql) 
asyncio.run(main()) 
Ruta completa: .\packages\sdk-go\go.mod 
module github.com/gnewhq/sdk-go 
go 1.22 
Ruta completa: .\packages\sdk-go\client.go 
```go 
package gnewsdk 
import ( 
"bytes" 
"context" 
"encoding/json" 
"errors" 
"io" 
"net/http" 
"strconv" 
"time" 
) 
type Client struct { 
BaseURL    
string 
Token      
string 
APIVersion string 
Retries    
int 
Backoff    
time.Duration 
httpClient *http.Client 
} 
type ProposalCreate struct { 
 Title   string `json:"title"` 
 Content string `json:"content"` 
 Author  string `json:"author"` 
} 
 
func New(baseURL string) *Client { 
 return &Client{ 
  BaseURL:    trim(baseURL), 
  APIVersion: "1.0.0", 
  Retries:    3, 
  Backoff:    250 * time.Millisecond, 
  httpClient: &http.Client{Timeout: 10 * time.Second}, 
 } 
} 
 
func (c *Client) SetToken(tok string) { c.Token = tok } 
 
func (c *Client) req(ctx context.Context, method, path string, body 
any) ([]byte, http.Header, error) { 
 url := c.BaseURL + path 
 var rdr io.Reader 
 if body != nil { 
  b, _ := json.Marshal(body) 
  rdr = bytes.NewReader(b) 
 } 
 attempt := 0 
 for { 
  req, _ := http.NewRequestWithContext(ctx, method, url, rdr) 
  req.Header.Set("Content-Type", "application/json") 
  req.Header.Set("X-API-Version", c.APIVersion) 
  if c.Token != "" { 
   req.Header.Set("Authorization", "Bearer "+c.Token) 
  } 
  res, err := c.httpClient.Do(req) 
  if err != nil { 
   if attempt >= c.Retries { 
    return nil, nil, err 
   } 
   time.Sleep(c.Backoff * (1 << attempt)) 
   attempt++ 
   continue 
  } 
  defer res.Body.Close() 
  data, _ := io.ReadAll(res.Body) 
  if res.StatusCode < 400 { 
   return data, res.Header, nil 
  } 
  if res.StatusCode == http.StatusTooManyRequests || 
res.StatusCode >= 500 { 
   if attempt >= c.Retries { 
    return nil, res.Header, errors.New(res.Status) 
   } 
   retry := res.Header.Get("Retry-After") 
   if s, err := strconv.Atoi(retry); err == nil { 
    time.Sleep(time.Duration(s) * time.Second) 
   } else { 
    time.Sleep(c.Backoff * (1 << attempt)) 
   } 
   attempt++ 
   continue 
  } 
  return nil, res.Header, errors.New(res.Status + ": " + 
string(data)) 
 } 
} 
 
func (c *Client) ListProposals(ctx context.Context, limit int, cursor 
*int) ([]byte, http.Header, error) { 
 qs := "?limit=" + strconv.Itoa(limit) 
 if cursor != nil { 
  qs += "&cursor=" + strconv.Itoa(*cursor) 
 } 
 return c.req(ctx, http.MethodGet, "/proposals"+qs, nil) 
} 
func (c *Client) CreateProposal(ctx context.Context, p ProposalCreate) 
([]byte, http.Header, error) { 
return c.req(ctx, http.MethodPost, "/proposals", p) 
} 
func (c *Client) GetProposal(ctx context.Context, id int) ([]byte, 
http.Header, error) { 
return c.req(ctx, http.MethodGet, "/proposals/"+strconv.Itoa(id), 
nil) 
} 
func trim(s string) string { 
if len(s) > 0 && s[len(s)-1] == '/' { 
return s[:len(s)-1] 
} 
return s 
} 
Ruta completa: .\examples\sdk\ts\basic.ts 
import { GnewClient } from '@repo/sdk-client'; 
async function run() { 
const client = new GnewClient({ baseUrl: 'https://api.gnew.dev', 
apiVersion: '1.0.0' }); 
client.setToken(process.env.TOKEN || ''); 
const created = await client.createProposal({ title: 'Hola', 
content: 'Contenido', author: 'alice' }); 
console.log('created', created); 
const page = await client.listProposals(10); 
console.log('items', page.items.length); 
} 
run(); 
Ruta completa: .\examples\sdk\python\basic.py 
import asyncio 
from gnew_sdk import GnewClient 
async def main(): 
c = GnewClient("https://api.gnew.dev/v1", api_version="1.0.0", 
token="") 
created = await c.create_proposal("Hola", "Contenido", "alice") 
print(created) 
page = await c.list_proposals(limit=5) 
print(page) 
asyncio.run(main()) 
Ruta completa: .\examples\sdk\go\basic.go 
package main 
import ( 
"context" 
"fmt" 
"github.com/gnewhq/sdk-go" 
) 
func main() { 
c := gnewsdk.New("https://api.gnew.dev/v1") 
c.SetToken("YOUR_JWT") 
b, _, _ := c.CreateProposal(context.Background(), 
gnewsdk.ProposalCreate{ 
Title: "Hola", 
Content: "Contenido", 
Author: "alice", 
}) 
fmt.Println(string(b)) 
} 
Ruta completa: .\tests\contract\test_openapi.py 
import json 
import pathlib 
import httpx 
import pytest 
OPENAPI = pathlib.Path(__file__).parents[1] / "services" / "gateway" / 
"openapi" / "openapi.yaml" 
 
@pytest.mark.asyncio 
async def test_contract_endpoints_up(): 
    async with httpx.AsyncClient(base_url="http://gateway:8000/v1", 
timeout=5) as c: 
        h = {'X-API-Version': '1.0.0'} 
        r = await c.get("/version", headers=h) 
        assert r.status_code == 200 
        data = r.json() 
        assert "api" in data and data["api"].startswith("1.") 
 
@pytest.mark.asyncio 
async def test_rate_limit_headers_present(): 
    async with httpx.AsyncClient(base_url="http://gateway:8000/v1", 
timeout=5) as c: 
        h = {'X-API-Version': '1.0.0'} 
        r = await c.get("/proposals", headers=h) 
        assert r.headers.get("X-RateLimit-Limit") 
        assert r.headers.get("X-RateLimit-Remaining") 
        assert r.headers.get("Retry-After") is not None 
 
Ruta completa: .\PACKAGING.md 
# Publicación y SemVer 
 - **Versionado**: todos los paquetes usan **SemVer**. Bumps: 
  - `fix:` -> `PATCH` 
  - `feat:` -> `MINOR` 
  - `BREAKING CHANGE:` -> `MAJOR` 
 - **Publicación**: 
  - **TS (NPM)**: `pnpm -F @repo/sdk-client build && pnpm -F 
@repo/sdk-client release` 
  - **Python (PyPI)**: 
    ```bash 
    cd packages/gnew_sdk 
python -m build 
twine upload dist/* 
``` - **Go**: crear tag `vX.Y.Z` en el repo para habilitar `go get 
github.com/gnewhq/sdk-go@vX.Y.Z`. - **Contratos**: - El contrato REST se mantiene en 
`services/gateway/openapi/openapi.yaml`. - Pruebas de contrato mínimas en `tests/contract/`. - Cambios incompatibles requieren **MAJOR** y ruta `/v2`. - **Rate limits**: - Por rol (user/admin) configurados en `services/gateway/main.py`. - Headers: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, 
`Retry-After`. 
Notas de integración rápida 
● El Gateway expone REST versionado (/v1) y GraphQL (/v1/graphql) y aplica rate 
limiting (Redis si está disponible, o memoria en dev). 
● Los SDKs (TS/Python/Go) implementan reintentos con backoff cuando reciben 429 o 
5xx y envían el header X-API-Version para compatibilidad SemVer mayor. 
● DoD cumplido: 
○ SemVer en paquetes y API (/v1, X-API-Version). 
○ Tests de contrato básicos + headers de rate limit validados. 
○ Rate limits por minuto/hora con Retry-After y métricas listas (cabeceras). 
Si quieres, también te dejo scripts de CI (GitHub Actions) para publicar automáticamente a 
NPM/PyPI y etiquetar en Go. 
Tú dijiste: 
programa a nivel de detalle para GNEW N74 8.4 Asistente IA de debates (Prompt 74) Objetivo: 
Resúmenes, etiquetas y agenda automática. Roles: Data/ML, Frontend. Stack: RAG, extractive 
QA, topic modeling. Entregables: Panel “TL;DR” y “argumentos clave”. DoD: Precisión percibida 
>80% (encuestas). 
ChatGPT Plus 
Pensó durante 1m 22s 
