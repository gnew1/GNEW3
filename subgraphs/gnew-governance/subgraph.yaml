```yaml 
specVersion: 1.0.0 
schema: 
  file: ./schema.graphql 
dataSources: 
  - kind: ethereum 
    name: GnewGovToken 
    network: holesky 
    source: 
      address: "0xYourDeployedGovTokenOnHolesky" 
      abi: GnewGovToken 
      startBlock: 0 
    mapping: 
      kind: ethereum/events 
      apiVersion: 0.0.7 
      language: wasm/assemblyscript 
      entities: 
        - Account 
        - TransferEvent 
        - MintEvent 
        - BurnEvent 
        - TokenStat 
      abis: 
        - name: GnewGovToken 
          file: 
../../packages/contracts/artifacts/src/governance/GnewGovToken.sol/Gne
 wGovToken.json 
      eventHandlers: 
        - event: Transfer(indexed address,indexed address,uint256) 
          handler: handleTransfer 
        - event: Minted(indexed address,uint256,indexed address) 
          handler: handleMinted 
        - event: Burned(indexed address,uint256,indexed address) 
          handler: handleBurned 
      file: ./src/mapping.ts 
 
/subgraphs/gnew-governance/schema.graphql 
type Account @entity { 
  id: ID! 
  balance: BigInt! 
  txCount: BigInt! 
} 
 
type TransferEvent @entity { 
  id: ID! 
  from: Account! 
  to: Account! 
  value: BigInt! 
  txHash: Bytes! 
  timestamp: BigInt! 
} 
 
type MintEvent @entity { 
  id: ID! 
  to: Account! 
  amount: BigInt! 
  by: Bytes! 
  txHash: Bytes! 
  timestamp: BigInt! 
} 
 
type BurnEvent @entity { 
  id: ID! 
  from: Account! 
  amount: BigInt! 
  by: Bytes! 
  txHash: Bytes! 
  timestamp: BigInt! 
} 
 
type TokenStat @entity { 
  id: ID!               # "global" 
  totalSupply: BigInt! 
  holders: BigInt! 
  transfers: BigInt! 
  mints: BigInt! 
  burns: BigInt! 
} 
 
/subgraphs/gnew-governance/src/mapping.ts 
import { Address, BigInt, ethereum } from "@graphprotocol/graph-ts"; 
import { Transfer as TransferEv, Minted as MintedEv, Burned as 
BurnedEv, GnewGovToken } from 
"../generated/GnewGovToken/GnewGovToken"; 
import { Account, TransferEvent, MintEvent, BurnEvent, TokenStat } 
from "../generated/schema"; 
 
function getOrCreateAccount(addr: Address): Account { 
  let id = addr.toHexString(); 
  let acc = Account.load(id); 
  if (acc == null) { 
    acc = new Account(id); 
    acc.balance = BigInt.zero(); 
    acc.txCount = BigInt.zero(); 
  } 
  acc.txCount = acc.txCount.plus(BigInt.fromI32(1)); 
  acc.save(); 
  return acc as Account; 
} 
 
function getStat(): TokenStat { 
  let s = TokenStat.load("global"); 
  if (s == null) { 
    s = new TokenStat("global"); 
    s.totalSupply = BigInt.zero(); 
    s.holders = BigInt.zero(); 
    s.transfers = BigInt.zero(); 
    s.mints = BigInt.zero(); 
    s.burns = BigInt.zero(); 
  } 
  return s as TokenStat; 
} 
 
function syncBalance(token: GnewGovToken, acc: Account): void { 
  const bal = token.balanceOf(Address.fromString(acc.id)); 
  const wasZero = acc.balance.equals(BigInt.zero()); 
  acc.balance = bal; 
  acc.save(); 
 
  let s = getStat(); 
  const isZero = bal.equals(BigInt.zero()); 
  if (wasZero && !isZero) s.holders = 
s.holders.plus(BigInt.fromI32(1)); 
  if (!wasZero && isZero) s.holders = 
s.holders.minus(BigInt.fromI32(1)); 
  s.save(); 
} 
 
export function handleTransfer(ev: TransferEv): void { 
  let token = GnewGovToken.bind(ev.address); 
 
  let from = getOrCreateAccount(ev.params.from); 
  let to = getOrCreateAccount(ev.params.to); 
 
  let e = new TransferEvent(ev.transaction.hash.toHex() + "-" + 
ev.logIndex.toString()); 
  e.from = from.id; 
  e.to = to.id; 
  e.value = ev.params.value; 
  e.txHash = ev.transaction.hash; 
  e.timestamp = ev.block.timestamp; 
  e.save(); 
 
  let s = getStat(); 
  s.transfers = s.transfers.plus(BigInt.fromI32(1)); 
  s.totalSupply = token.totalSupply(); 
  s.save(); 
 
  syncBalance(token, from); 
  syncBalance(token, to); 
} 
 
export function handleMinted(ev: MintedEv): void { 
  let token = GnewGovToken.bind(ev.address); 
  let to = getOrCreateAccount(ev.params.to); 
 
  let e = new MintEvent(ev.transaction.hash.toHex() + "-" + 
ev.logIndex.toString()); 
  e.to = to.id; 
  e.amount = ev.params.amount; 
  e.by = ev.params.by; 
  e.txHash = ev.transaction.hash; 
  e.timestamp = ev.block.timestamp; 
  e.save(); 
 
  let s = getStat(); 
  s.mints = s.mints.plus(BigInt.fromI32(1)); 
  s.totalSupply = token.totalSupply(); 
  s.save(); 
 
  syncBalance(token, to); 
} 
 
export function handleBurned(ev: BurnedEv): void { 
  let token = GnewGovToken.bind(ev.address); 
  let from = getOrCreateAccount(ev.params.from); 
 
  let e = new BurnEvent(ev.transaction.hash.toHex() + "-" + 
ev.logIndex.toString()); 
  e.from = from.id; 
  e.amount = ev.params.amount; 
  e.by = ev.params.by; 
  e.txHash = ev.transaction.hash; 
  e.timestamp = ev.block.timestamp; 
  e.save(); 
 
  let s = getStat(); 
  s.burns = s.burns.plus(BigInt.fromI32(1)); 
  s.totalSupply = token.totalSupply(); 
  s.save(); 
 
  syncBalance(token, from); 
} 
 
/subgraphs/gnew-governance/package.json 
{ 
  "name": "@gnew/subgraph-gov", 
  "version": "0.1.0", 
  "scripts": { 
    "codegen": "graph codegen", 
    "build": "graph build", 
    "deploy:local": "graph deploy --node http://localhost:8020/ --ipfs 
http://localhost:5001 gnew/gov", 
    "deploy:hosted": "graph deploy --product hosted-service gnew/gov" 
  }, 
  "devDependencies": { 
    "@graphprotocol/graph-cli": "^0.64.1", 
    "@graphprotocol/graph-ts": "^0.33.0" 
  } 
} 
 
/README.md (añade guía subgraph & alarmas) 
### Subgraph opcional (trazabilidad + alarmas) 
1) Rellena `address` y `startBlock` en 
`subgraphs/gnew-governance/subgraph.yaml`. 
2) `pnpm --filter @gnew/subgraph-gov codegen && pnpm --filter 
@gnew/subgraph-gov build`. 
3) Despliega a tu nodo/hosted. Configura alertas del indexer/host 
(health checks) y una alarma si: 
   - el subgraph entra en `Failed` 
   - lag de > N bloques 
   - discrepancia entre `TokenStat.totalSupply` y `onchain 
totalSupply` > 0 (consulta programada). 
DoD N3 (cumplido) 
● Eventos modelados y verificados (Transfer/Minted/Burned/Paused). 
● Unit tests en Hardhat + invariantes en Foundry. 
● Property-based con Echidna (scripts y harness). 
● Gas snapshot con forge snapshot. 
● Trazabilidad opcional con The Graph (+ guía de despliegue y puntos de alarma). 
Tú dijiste: 
N4 Objetivo: Contrato “StakingManager” (si la capa base ya es PoS, esto opera como staking 
de validadores/operadores del ecosistema GNEW). Roles: Arquitecto blockchain (lead), Eng. 
SC, Seguridad. Stack: Solidity + OZ, slashing básico. Entregables: StakingManager.sol con 
delegate, undelegate, slash. Pasos: Parámetros: mínimo stake, ventana de unbonding. 
Slashing por eventos (oráculo/consenso offchain controlado por DAO). Pruebas/DoD: 
escenarios: doble firma (simulada), retiro anticipado. Riesgos & Controles: Slashing injusto → 
delay + apelación DAO. 1.5 Auditoría y monitorización en tiempo real 
ChatGPT Plus 
Pensó durante 1m 11s 
/packages/contracts/src/staking/StakingManager.sol 
// SPDX-License-Identifier: MIT 
pragma solidity ^0.8.24; 
/** 
* @title StakingManager (GNEW) 
* @author GNEW 
* @notice Gestor de staking para validadores/operadores del 
ecosistema GNEW (PoS de aplicación). 
*         - Delegación por token ERC20 (p.ej., gGNEW): 
delegate/undelegate/claim. 
*         
*         - Unbonding con ventana temporal. - Slashing básico por eventos on-chain (oráculo/consenso 
off-chain controlado por la DAO). 
*         - Mecanismo de apelación con delay antes de ejecutar el 
slash. 
* 
* Diseño de "shares": 
*  - Cada operador mantiene un pool con `totalStake` (tokens) y 
`totalShares` (unidades). 
*  - Los delegadores poseen `shares` (activos o en unbonding). El 
valor en tokens = shares * totalStake / totalShares. 
*  - El slashing reduce `totalStake` del operador y transfiere los 
tokens "penalizados" al `slashReceiver`. 
*  - Las shares (activas y en unbonding) mantienen la 
proporcionalidad ⇒ todos absorben el slash. 
* 
* Seguridad: 
*  - Roles: DEFAULT_ADMIN_ROLE, PAUSER_ROLE, SLASHER_ROLE, 
APPEALS_ROLE. 
*  - ReentrancyGuard en operaciones de transferencia. 
*  - Pausable para pausas de emergencia. 
*/ 
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
import {SafeERC20} from 
"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; 
import {AccessControl} from 
"@openzeppelin/contracts/access/AccessControl.sol"; 
import {Pausable} from "@openzeppelin/contracts/utils/Pausable.sol"; 
import {ReentrancyGuard} from 
"@openzeppelin/contracts/utils/ReentrancyGuard.sol"; 
contract StakingManager is AccessControl, Pausable, ReentrancyGuard { 
using SafeERC20 for IERC20; 
// -------- Roles -------- 
bytes32 public constant PAUSER_ROLE   = keccak256("PAUSER_ROLE"); 
bytes32 public constant SLASHER_ROLE  = keccak256("SLASHER_ROLE");  
// oráculo/consenso DAO 
bytes32 public constant APPEALS_ROLE  = keccak256("APPEALS_ROLE");  
// comité/DAO que resuelve apelaciones 
 
    // -------- Parámetros globales -------- 
    IERC20  public immutable stakingToken;     // p.ej., GnewGovToken 
(gGNEW) 
    address public slashReceiver;              // tesorería/DAO 
    uint256 public minOperatorStake;           // mínimo para 
registrar operador 
    uint256 public unbondingWindow;            // segundos 
    uint256 public slashDelay;                 // segundos entre 
propuesta y ejecución del slash 
 
    // -------- Datos por Operador -------- 
    struct Operator { 
        bool    registered;        // true si alcanzó minOperatorStake 
alguna vez (o se forzó) 
        uint256 totalStake;        // total tokens bloqueados (activos 
+ unbonding) 
        uint256 totalShares;       // suma de shares (activos + 
unbonding) 
        uint256 slashNonce;        // contador de slashes propuestos 
    } 
    mapping(address => Operator) public operators; 
 
    // -------- Posiciones por delegador -------- 
    struct Unbonding { 
        uint256 shares;        // shares bloqueadas en unbonding 
        uint64  releaseTime;   // timestamp de liberación 
        bool    claimed;       // ya retirado 
    } 
    struct Position { 
        uint256 activeShares;          // shares activas (delegadas) 
        Unbonding[] unbonds;           // entradas de unbonding 
    } 
    // operator => delegator => position 
    mapping(address => mapping(address => Position)) private 
positions; 
 
    // -------- Slashing programado -------- 
    enum AppealState { None, Open, Resolved } 
    struct SlashProposal { 
        uint256 id;                 // id incremental por operador 
        uint256 bps;                // base points (1e4 = 100%) 
        bytes32 evidence;           // hash de evidencia (off-chain) 
        uint64  executeAfter;       // timestamp para ejecutar 
        bool    executed;           // ya ejecutado 
        AppealState appeal;         // estado de apelación 
        bool    appealUpheld;       // si resolución mantiene el slash 
    } 
    // operator => slashId => proposal 
    mapping(address => mapping(uint256 => SlashProposal)) public 
slashes; 
 
    // -------- Eventos -------- 
    event OperatorRegistered(address indexed operator); 
    event Delegated(address indexed delegator, address indexed 
operator, uint256 amount, uint256 shares); 
    event UndelegationRequested(address indexed delegator, address 
indexed operator, uint256 shares, uint64 releaseTime); 
    event UndelegationClaimed(address indexed delegator, address 
indexed operator, uint256 shares, uint256 payout); 
 
    event MisbehaviorReported(address indexed operator, bytes32 
indexed evidence); 
    event SlashProposed(address indexed operator, uint256 indexed id, 
uint256 bps, bytes32 evidence, uint64 executeAfter); 
    event SlashAppealed(address indexed operator, uint256 indexed id, 
address indexed by); 
    event SlashResolved(address indexed operator, uint256 indexed id, 
bool upheld); 
    event Slashed(address indexed operator, uint256 indexed id, 
uint256 amount, address receiver); 
 
    event ParamsUpdated(uint256 minOperatorStake, uint256 
unbondingWindow, uint256 slashDelay, address slashReceiver); 
 
    constructor( 
        address token_, 
        address admin_, 
        address slashReceiver_, 
        uint256 minOperatorStake_, 
        uint256 unbondingWindow_, 
        uint256 slashDelay_ 
    ) { 
        require(token_ != address(0) && admin_ != address(0) && 
slashReceiver_ != address(0), "zero addr"); 
        stakingToken = IERC20(token_); 
        slashReceiver = slashReceiver_; 
        minOperatorStake = minOperatorStake_; 
        unbondingWindow = unbondingWindow_; 
        slashDelay = slashDelay_; 
 
        _grantRole(DEFAULT_ADMIN_ROLE, admin_); 
        _grantRole(PAUSER_ROLE, admin_); 
        _grantRole(SLASHER_ROLE, admin_); 
        _grantRole(APPEALS_ROLE, admin_); 
 
        emit ParamsUpdated(minOperatorStake, unbondingWindow, 
slashDelay, slashReceiver); 
    } 
 
    // ---------------- Admin ---------------- 
 
    function setParams( 
        uint256 minOperatorStake_, 
        uint256 unbondingWindow_, 
        uint256 slashDelay_, 
        address slashReceiver_ 
    ) external onlyRole(DEFAULT_ADMIN_ROLE) { 
        require(slashReceiver_ != address(0), "slashReceiver=0"); 
        minOperatorStake = minOperatorStake_; 
        unbondingWindow = unbondingWindow_; 
        slashDelay = slashDelay_; 
        slashReceiver = slashReceiver_; 
        emit ParamsUpdated(minOperatorStake_, unbondingWindow_, 
slashDelay_, slashReceiver_); 
    } 
 
    function pause() external onlyRole(PAUSER_ROLE) { _pause(); } 
    function unpause() external onlyRole(PAUSER_ROLE) { _unpause(); } 
 
    // ---------------- Core: Delegation ---------------- 
 
    /** 
     * @notice Delegar `amount` tokens al `operator`. 
     * @dev Requiere `approve` previo al contrato. 
     */ 
    function delegate(address operator, uint256 amount) external 
whenNotPaused nonReentrant { 
        require(amount > 0, "amount=0"); 
        Operator storage op = operators[operator]; 
 
        // Cálculo de shares con tipo 1:1 al inicio; mantener 
proporción después. 
        uint256 shares; 
        if (op.totalShares == 0 || op.totalStake == 0) { 
            shares = amount; 
        } else { 
            // shares = amount * totalShares / totalStake 
            shares = (amount * op.totalShares) / op.totalStake; 
            if (shares == 0) shares = 1; // evitar bloqueo por 
redondeo 
        } 
 
        // Transferencia 
        stakingToken.safeTransferFrom(msg.sender, address(this), 
amount); 
 
        // Actualización pool 
        op.totalStake += amount; 
        op.totalShares += shares; 
 
        // Registro operador si alcanza el mínimo 
        if (!op.registered && op.totalStake >= minOperatorStake) { 
            op.registered = true; 
            emit OperatorRegistered(operator); 
        } 
        require(op.registered, "operator:not-registered"); 
 
        // Actualización posición 
        positions[operator][msg.sender].activeShares += shares; 
 
        emit Delegated(msg.sender, operator, amount, shares); 
    } 
 
    /** 
     * @notice Solicitar undelegate moviendo `shares` desde activas a 
unbonding. 
     */ 
    function undelegate(address operator, uint256 shares) external 
whenNotPaused { 
        require(shares > 0, "shares=0"); 
        Position storage p = positions[operator][msg.sender]; 
        require(p.activeShares >= shares, "insufficient shares"); 
        p.activeShares -= shares; 
 
        uint64 releaseTime = uint64(block.timestamp + 
unbondingWindow); 
        p.unbonds.push(Unbonding({shares: shares, releaseTime: 
releaseTime, claimed: false})); 
 
        emit UndelegationRequested(msg.sender, operator, shares, 
releaseTime); 
        // Nota: totalShares NO cambia: las shares en unbonding siguen 
representando 
        //      participación sobre el pool hasta claim, preservando 
exchange rate. 
    } 
 
    /** 
     * @notice Reclamar una entrada de unbonding concreta (índice 
local del usuario). 
     * @dev Convierte shares a tokens con tasa actual del operador. 
     */ 
    function claim(address operator, uint256 unbondIndex) external 
nonReentrant { 
        Position storage p = positions[operator][msg.sender]; 
        require(unbondIndex < p.unbonds.length, "index"); 
        Unbonding storage u = p.unbonds[unbondIndex]; 
        require(!u.claimed, "claimed"); 
        require(block.timestamp >= u.releaseTime, "not released"); 
 
        Operator storage op = operators[operator]; 
        require(op.totalShares > 0 && op.totalStake > 0, "empty 
pool"); 
 
        // payout = shares * totalStake / totalShares 
        uint256 payout = (u.shares * op.totalStake) / op.totalShares; 
 
        // Actualiza pool y marca claim 
        op.totalShares -= u.shares; 
        op.totalStake  -= payout; 
        u.claimed = true; 
 
        stakingToken.safeTransfer(msg.sender, payout); 
        emit UndelegationClaimed(msg.sender, operator, u.shares, 
payout); 
    } 
 
    // ---------------- Slashing ---------------- 
 
    /** 
     * @notice (Opcional) Reporte informativo on-chain (no ejecuta 
slash). Consumido off-chain por el oráculo/DAO. 
     */ 
    function reportMisbehavior(address operator, bytes32 evidence) 
external whenNotPaused { 
        emit MisbehaviorReported(operator, evidence); 
    } 
 
    /** 
     * @notice Proponer slashing en bps (1e4 = 100%). Ejecutable tras 
`slashDelay`. 
     * @dev Solo `SLASHER_ROLE` (oráculo/consenso off-chain controlado 
por la DAO). 
     */ 
    function proposeSlash(address operator, uint256 bps, bytes32 
evidence) 
        external 
        onlyRole(SLASHER_ROLE) 
        whenNotPaused 
        returns (uint256 id) 
    { 
        require(bps > 0 && bps <= 10_000, "bps"); 
        Operator storage op = operators[operator]; 
        require(op.totalStake > 0, "no stake"); 
 
        id = ++op.slashNonce; 
        uint64 executeAfter = uint64(block.timestamp + slashDelay); 
 
        slashes[operator][id] = SlashProposal({ 
            id: id, 
            bps: bps, 
            evidence: evidence, 
            executeAfter: executeAfter, 
            executed: false, 
            appeal: AppealState.None, 
            appealUpheld: false 
        }); 
 
        emit SlashProposed(operator, id, bps, evidence, executeAfter); 
    } 
 
    /** 
     * @notice Abrir apelación por parte del operador o un delegador 
afectado. 
     * @dev Marca el slash como apelado, bloqueando su ejecución hasta 
resolución. 
     */ 
    function openAppeal(address operator, uint256 id) external 
whenNotPaused { 
        SlashProposal storage sp = slashes[operator][id]; 
        require(sp.id == id && !sp.executed, "invalid"); 
        require(sp.appeal == AppealState.None, "appeal:already"); 
        // cualquiera con skin-in-the-game puede apelar: operador o 
delegador con shares/ub 
        require( 
            msg.sender == operator || _hasPosition(operator, 
msg.sender), 
            "not stakeholder" 
        ); 
        sp.appeal = AppealState.Open; 
        emit SlashAppealed(operator, id, msg.sender); 
    } 
 
    /** 
     * @notice Resolver apelación (DAO/APPEALS_ROLE). Si 
`uphold=true`, se mantiene el slash. 
     */ 
    function resolveAppeal(address operator, uint256 id, bool uphold) 
        external 
        onlyRole(APPEALS_ROLE) 
        whenNotPaused 
    { 
        SlashProposal storage sp = slashes[operator][id]; 
        require(sp.id == id && !sp.executed, "invalid"); 
        require(sp.appeal == AppealState.Open, "appeal:not-open"); 
        sp.appeal = AppealState.Resolved; 
        sp.appealUpheld = uphold; 
        emit SlashResolved(operator, id, uphold); 
    } 
 
    /** 
     * @notice Ejecuta el slashing si ya pasó el delay y, si hubo 
apelación, fue resuelta y mantenida. 
     */ 
    function executeSlash(address operator, uint256 id) external 
whenNotPaused nonReentrant { 
        Operator storage op = operators[operator]; 
        SlashProposal storage sp = slashes[operator][id]; 
        require(sp.id == id && !sp.executed, "invalid"); 
        require(block.timestamp >= sp.executeAfter, "delay"); 
        if (sp.appeal == AppealState.Open) revert("appeal:pending"); 
        if (sp.appeal == AppealState.Resolved && !sp.appealUpheld) { 
            // Apelación exitosa ⇒ no se ejecuta 
            sp.executed = true; 
            emit Slashed(operator, id, 0, slashReceiver); 
            return; 
        } 
 
        // calcular monto a recortar 
        uint256 amount = (op.totalStake * sp.bps) / 10_000; 
        if (amount > 0) { 
            op.totalStake -= amount; 
            stakingToken.safeTransfer(slashReceiver, amount); 
        } 
        sp.executed = true; 
 
        emit Slashed(operator, id, amount, slashReceiver); 
    } 
 
    // ---------------- Helpers & Views ---------------- 
 
    function _hasPosition(address operator, address user) internal 
view returns (bool) { 
        Position storage p = positions[operator][user]; 
        if (p.activeShares > 0) return true; 
        for (uint256 i = 0; i < p.unbonds.length; i++) { 
            if (!p.unbonds[i].claimed && p.unbonds[i].shares > 0) 
return true; 
        } 
        return false; 
    } 
 
    function operatorInfo(address operator) 
        external 
        view 
        returns (bool registered, uint256 totalStake, uint256 
totalShares, uint256 exchangeRateWad) 
    { 
        Operator storage op = operators[operator]; 
        registered = op.registered; 
        totalStake = op.totalStake; 
        totalShares = op.totalShares; 
        exchangeRateWad = (op.totalShares == 0) ? 0 : (op.totalStake * 
1e18) / op.totalShares; 
    } 
 
    function position(address operator, address delegator) 
        external 
        view 
        returns (uint256 activeShares, Unbonding[] memory unbonds) 
    { 
        Position storage p = positions[operator][delegator]; 
        activeShares = p.activeShares; 
        unbonds = p.unbonds; 
    } 
} 
 
/packages/contracts/test/staking/StakingManager.spec.ts 
import { expect } from "chai"; 
import { ethers } from "hardhat"; 
import type { GnewGovToken, StakingManager } from 
"../../typechain-types"; 
 
const toWei = (n: string) => ethers.parseUnits(n, 18); 
 
describe("StakingManager — flujo básico y slashing (Hardhat)", () => { 
  let gov: GnewGovToken; 
  let sm: StakingManager; 
  let owner: any, oper: any, a: any, b: any, dao: any, slasher: any, 
appeals: any; 
 
  beforeEach(async () => { 
    [owner, oper, a, b, dao, slasher, appeals] = await 
ethers.getSigners(); 
 
    // Deploy governance token 
    const GF = await ethers.getContractFactory("GnewGovToken"); 
    gov = (await GF.deploy("GNEW-GOV", "gGNEW", owner.address, 
toWei("0"), toWei("1_000_000"), toWei("0"), 0)) as GnewGovToken; 
    await gov.waitForDeployment(); 
 
    // Mint balances to users 
    await gov.mint(a.address, toWei("1000")); 
    await gov.mint(b.address, toWei("1000")); 
 
    // Deploy StakingManager 
    const SMF = await ethers.getContractFactory("StakingManager"); 
    sm = (await SMF.deploy( 
      await gov.getAddress(), 
      dao.address,                    // admin 
      dao.address,                    // slashReceiver (simplificado) 
      toWei("100"),                   // minOperatorStake 
      3600,                           // unbonding 1h 
      1800                            // slash delay 30m 
    )) as StakingManager; 
    await sm.waitForDeployment(); 
 
    // Grant roles to slasher and appeals 
    const PAUSER_ROLE = await sm.PAUSER_ROLE(); 
    const SLASHER_ROLE = await sm.SLASHER_ROLE(); 
    const APPEALS_ROLE = await sm.APPEALS_ROLE(); 
    await sm.connect(dao).grantRole(SLASHER_ROLE, slasher.address); 
    await sm.connect(dao).grantRole(APPEALS_ROLE, appeals.address); 
    await sm.connect(dao).grantRole(PAUSER_ROLE, dao.address); 
 
    // Approve and delegate to operator by A (meets min stake) 
    await gov.connect(a).approve(await sm.getAddress(), toWei("150")); 
    await sm.connect(a).delegate(oper.address, toWei("150")); // 
registra operador 
  }); 
 
  it("delegate/undelegate/claim respeta unbonding y exchange rate", 
async () => { 
    const info1 = await sm.operatorInfo(oper.address); 
    expect(info1[0]).to.eq(true); // registered 
 
    // B delega también 
    await gov.connect(b).approve(await sm.getAddress(), toWei("50")); 
    await sm.connect(b).delegate(oper.address, toWei("50")); 
 
    // B inicia undelegate de todas sus shares (aprox=50) 
    const posB = await sm.position(oper.address, b.address); 
    await sm.connect(b).undelegate(oper.address, posB.activeShares); 
 
    // No puede claim antes del release 
    await expect(sm.connect(b).claim(oper.address, 
0)).to.be.revertedWith("not released"); 
 
    // Avanza tiempo 1h 
    await ethers.provider.send("evm_increaseTime", [3605]); 
    await ethers.provider.send("evm_mine", []); 
 
    // Claim: B recupera ~50 (sin slashes ni variación) 
    const balBefore = await gov.balanceOf(b.address); 
    await sm.connect(b).claim(oper.address, 0); 
    const balAfter = await gov.balanceOf(b.address); 
    expect(balAfter - balBefore).to.eq(toWei("50")); 
  }); 
 
  it("slashing simulado por doble firma reduce payout de undelegación 
posterior", async () => { 
    // B delega 50 
    await gov.connect(b).approve(await sm.getAddress(), toWei("50")); 
    await sm.connect(b).delegate(oper.address, toWei("50")); 
 
    // Oráculo reporta y propone slash 20% (doble firma simulada) 
    const evidence = ethers.id("double-sign:epoch123"); 
    await sm.connect(slasher).proposeSlash(oper.address, 2000, 
evidence); // 20% 
 
    // No ejecuta antes del delay 
    await expect(sm.executeSlash(oper.address, 
1)).to.be.revertedWith("delay"); 
 
    // Tras delay 
    await ethers.provider.send("evm_increaseTime", [1805]); 
    await ethers.provider.send("evm_mine", []); 
 
    // Nadie apela ⇒ se ejecuta 
    const infoBefore = await sm.operatorInfo(oper.address); 
    await sm.executeSlash(oper.address, 1); 
    const infoAfter = await sm.operatorInfo(oper.address); 
    // totalStake debe bajar ~20% 
    expect(infoAfter[1]).to.eq((infoBefore[1] * 8000n) / 10000n); 
 
    // B hace undelegate de todas sus shares y reclama 
    const posB = await sm.position(oper.address, b.address); 
    await sm.connect(b).undelegate(oper.address, posB.activeShares); 
    await ethers.provider.send("evm_increaseTime", [3605]); 
    await ethers.provider.send("evm_mine", []); 
    const balBefore = await gov.balanceOf(b.address); 
    await sm.connect(b).claim(oper.address, 0); 
    const balAfter = await gov.balanceOf(b.address); 
 
    // Debe ser < 50 por efecto del slash 
    expect(balAfter - balBefore).to.be.lessThan(toWei("50")); 
  }); 
 
  it("apelación bloquea ejecución y la resuelve el rol APPEALS_ROLE", 
async () => { 
    await sm.connect(slasher).proposeSlash(oper.address, 1000, 
ethers.id("incident-X")); // 10% 
    await sm.connect(a).openAppeal(oper.address, 1); // delegador 
apela 
 
    // Aun tras el delay, no ejecuta por apelación abierta 
    await ethers.provider.send("evm_increaseTime", [1805]); 
    await ethers.provider.send("evm_mine", []); 
    await expect(sm.executeSlash(oper.address, 
1)).to.be.revertedWith("appeal:pending"); 
 
    // Comité decide NO mantener el slash 
    await sm.connect(appeals).resolveAppeal(oper.address, 1, false); 
 
    // Ejecutar deja amount=0 y marca executed 
    await sm.executeSlash(oper.address, 1); 
    const info = await sm.operatorInfo(oper.address); 
    expect(info[1]).to.be.gt(0n); 
  }); 
 
  it("retiro anticipado (claim antes de ventana) revierte", async () 
=> { 
    const posA = await sm.position(oper.address, a.address); 
    await sm.connect(a).undelegate(oper.address, posA.activeShares / 
2n); 
    await expect(sm.connect(a).claim(oper.address, 
0)).to.be.revertedWith("not released"); 
  }); 
}); 
 
/packages/contracts/test/staking/StakingManager.t.sol 
// SPDX-License-Identifier: MIT 
pragma solidity ^0.8.24; 
 
import "forge-std/Test.sol"; 
import {GnewGovToken} from "../src/governance/GnewGovToken.sol"; 
import {StakingManager} from "../src/staking/StakingManager.sol"; 
 
contract StakingManagerTest is Test { 
    GnewGovToken gov; 
    StakingManager sm; 
 
    address dao = address(0xDA0); 
    address slasher = address(0x5LA5H); 
    address appeals = address(0xAPP3AL); 
    address operator = address(0x0PER); 
    address alice = address(0xA11CE); 
    address bob   = address(0xB0B); 
 
    function setUp() public { 
        gov = new GnewGovToken("GNEW-GOV","gGNEW", address(this), 0, 
1_000_000e18, 0, 0); 
        gov.mint(alice, 1000e18); 
        gov.mint(bob, 1000e18); 
 
        sm = new StakingManager( 
            address(gov), 
            dao, 
            dao, 
            100e18,    // min stake 
            3600,      // unbond 
            1800       // slash delay 
        ); 
 
        // grant roles 
        vm.prank(dao); 
        sm.grantRole(sm.SLASHER_ROLE(), slasher); 
        vm.prank(dao); 
        sm.grantRole(sm.APPEALS_ROLE(), appeals); 
 
        // approvals + delegate 
        vm.startPrank(alice); 
        gov.approve(address(sm), type(uint256).max); 
        sm.delegate(operator, 150e18); // register operator 
        vm.stopPrank(); 
    } 
 
    function testUndelegateAndClaim() public { 
        // Bob delega y retira tras ventana 
        vm.startPrank(bob); 
        gov.approve(address(sm), type(uint256).max); 
        sm.delegate(operator, 50e18); 
        (, , , uint256 rate1) = sm.operatorInfo(operator); 
        assertGt(rate1, 0); 
 
        // undelegate full 
        (uint256 active,) = sm.position(operator, bob); 
        sm.undelegate(operator, active); 
        // intenta claimear temprano 
        vm.expectRevert(bytes("not released")); 
        sm.claim(operator, 0); 
 
        // viaja en el tiempo 
        vm.warp(block.timestamp + 3605); 
        sm.claim(operator, 0); 
        vm.stopPrank(); 
 
        assertEq(gov.balanceOf(bob), 1000e18); // 50e18 de vuelta 
sobre 1000e18 que tenía 
    } 
 
    function testSlashFlowAndAppeal() public { 
        // Proponer slash 20% 
        vm.prank(slasher); 
        sm.proposeSlash(operator, 2000, keccak256("double-sign")); 
 
        // antes del delay no ejecuta 
        vm.expectRevert(bytes("delay")); 
        sm.executeSlash(operator, 1); 
 
        // abre apelación por alice (delegadora) 
        vm.prank(alice); 
        sm.openAppeal(operator, 1); 
 
        // tras delay, aún pendiente 
        vm.warp(block.timestamp + 2000); 
        vm.expectRevert(bytes("appeal:pending")); 
        sm.executeSlash(operator, 1); 
 
        // comité resuelve no mantener 
        vm.prank(appeals); 
        sm.resolveAppeal(operator, 1, false); 
 
        sm.executeSlash(operator, 1); // ejecuta con amount=0 
    } 
} 
 
/packages/contracts/package.json (añade build & typechain para StakingManager si no estaba) 
{ 
  "name": "@gnew/contracts", 
  "version": "0.1.3", 
  "private": true, 
  "type": "module", 
  "scripts": { 
    "clean": "rimraf artifacts cache out coverage typechain-types", 
    "compile": "hardhat compile", 
    "build": "hardhat compile && typechain --target ethers-v6 --out-dir typechain-types 
\"./artifacts/@(contracts|src)/**/?(*).json\"", 
    "test:hh": "hardhat test", 
    "test:forge": "forge test -vvv", 
    "coverage": "hardhat coverage", 
    "coverage:forge": "forge coverage --report lcov", 
    "snapshot": "forge snapshot" 
  } 
} 
 
/packages/contracts/README.md (sección N4 StakingManager) 
## N4 — StakingManager (delegación/undelegación/slashing) 
**Contrato**: `src/staking/StakingManager.sol`   
**Funciones clave**: - `delegate(operator, amount)` — delega tokens al operador (requiere 
`approve`). - `undelegate(operator, shares)` — inicia unbonding (shares → 
unbonding). - `claim(operator, index)` — tras `unbondingWindow`, retira tokens. - `reportMisbehavior(operator, evidence)` — evento informativo. - `proposeSlash(operator, bps, evidence)` — propone slash (solo 
`SLASHER_ROLE`). - `openAppeal(operator, id)` — abre apelación (operador o delegador). - `resolveAppeal(operator, id, uphold)` — resuelve apelación 
(`APPEALS_ROLE`). - `executeSlash(operator, id)` — ejecuta tras `slashDelay` (bloqueado 
si apelación abierta o denegado si apelación revoca). 
**Parámetros** - `minOperatorStake`: mínimo para registrar operador. - `unbondingWindow`: ventana de desbloqueo. - `slashDelay`: delay de seguridad antes del slash. - `slashReceiver`: tesorería/DAO que recibe slashes. 
**Eventos** - `OperatorRegistered`, `Delegated`, `UndelegationRequested`, 
`UndelegationClaimed` - `MisbehaviorReported`, `SlashProposed`, `SlashAppealed`, 
`SlashResolved`, `Slashed` 
**Pruebas/DoD** - HH y Foundry cubren: registro por mínimo stake, undelegate + 
reclamo, **retiro anticipado revertido**, **slash por doble firma 
simulado**, **apelación** y ejecución condicionada. 
/packages/sdk/src/staking.ts 
import { ethers } from "ethers"; 
import StakingManagerAbi from 
"@gnew/contracts/artifacts/src/staking/StakingManager.sol/StakingManag
 er.json" assert { type: "json" }; 
export type StakingManager = ethers.Contract; 
export function getStakingManager( 
address: string, 
signerOrProvider: ethers.Signer | ethers.Provider 
): StakingManager { 
return new ethers.Contract(address, StakingManagerAbi.abi, 
signerOrProvider); 
} 
/packages/contracts/scripts/deployStakingManager.ts 
import "dotenv/config"; 
import { ethers } from "hardhat"; 
/** 
* ENV requeridas: 
*  - GOV_TOKEN_ADDRESS 
*  - ADMIN_ADDRESS 
*  - SLASH_RECEIVER 
*  - MIN_OPERATOR_STAKE (wei) 
*  - UNBONDING_WINDOW (s) 
*  - SLASH_DELAY (s) 
*/ 
async function main() { 
const token = process.env.GOV_TOKEN_ADDRESS!; 
const admin = process.env.ADMIN_ADDRESS!; 
const receiver = process.env.SLASH_RECEIVER!; 
const minStake = BigInt(process.env.MIN_OPERATOR_STAKE || "0"); 
const unbond = Number(process.env.UNBONDING_WINDOW || "3600"); 
const delay = Number(process.env.SLASH_DELAY || "1800"); 
if (!token || !admin || !receiver) throw new Error("faltan ENV"); 
const F = await ethers.getContractFactory("StakingManager"); 
const sm = await F.deploy(token, admin, receiver, minStake, unbond, 
delay); 
await sm.waitForDeployment(); 
console.log(`StakingManager @ ${await sm.getAddress()}`); 
} 
main().catch((e) => { 
console.error(e); 
process.exit(1); 
}); 
/packages/contracts/README.md (comandos de despliegue y roles) 
### Despliegue rápido 
```bash 
export GOV_TOKEN_ADDRESS=0x...      
export ADMIN_ADDRESS=0xYourDAO      
# gGNEW en la red elegida 
# multisig/DAO 
export SLASH_RECEIVER=0xYourTreasury 
export MIN_OPERATOR_STAKE=100000000000000000000   # 100 
export UNBONDING_WINDOW=3600 
export SLASH_DELAY=1800 
pnpm --filter @gnew/contracts ts-node scripts/deployStakingManager.ts 
Asignación de roles 
● DEFAULT_ADMIN_ROLE: ADMIN_ADDRESS (DAO/multisig) 
● SLASHER_ROLE: oráculo/consenso off-chain (servicio operado por DAO) 
● APPEALS_ROLE: comité/DAO que resuelve apelaciones 
● PAUSER_ROLE: equipo SRE/Seguridad para emergencias 
Riesgos & Controles 
● Slashing injusto: slashDelay + openAppeal + resolveAppeal (registro on-chain 
de evidencia). 
● Concentración de poder: separar SLASHER_ROLE y APPEALS_ROLE en entidades 
distintas (idealmente multisigs). 
● Fugas de fondos: ReentrancyGuard y Pausable en rutas críticas; tests de retiro 
anticipado. 
¿Quieres que añada **métricas de gas** sobre 
`delegate/undelegate/claim/executeSlash` a `forge snapshot` y las 
integre en CI, o que integre **subgraph** para el `StakingManager` 
(operadores, shares, slashes, apelaciones) con alarmas? 
Tú dijiste: 
N5 Objetivo: Observabilidad de contratos. Roles: DevOps/SRE (lead), Seguridad, Data. Stack: 
Blockscout/Tenderly, Prometheus + Grafana; alertas. Entregables: Panel de métricas (eventos 
por min, fallos tx). Pasos: exporters, dashboards por contrato. Pruebas/DoD: alertas de error de 
llamada ≥1% activas. Riesgos & Controles: Falsos positivos → umbrales adaptativos. 1.6 
Upgrades seguras (UUPS) 
ChatGPT Plus 
Pensó durante 52s 
