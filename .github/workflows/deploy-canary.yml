name: Deploy Canary (ai-coordinator) 
 
on: 
  workflow_dispatch: 
    inputs: 
      image_tag: 
        description: "Nuevo tag de imagen" 
        required: true 
  push: 
    paths: 
      - "k8s/services/ai-coordinator/**" 
 
jobs: 
  update-image-and-apply: 
    runs-on: ubuntu-latest 
    steps: 
      - uses: actions/checkout@v4 
 
      # (A) Actualiza tag en kustomization o manifest (ejemplo sed 
simple) 
      - name: Bump image tag 
        run: | 
          sed -i 
"s#ghcr.io/gnew/ai-coordinator:.*#ghcr.io/gnew/ai-coordinator:${{ 
github.event.inputs.image_tag }}#g" \ 
            k8s/services/ai-coordinator/deployment-stable.yaml 
 
      # (B) (Opcional) Commit a repo GitOps (si usas ArgoCD/Flux) 
      - name: Commit change 
        run: | 
          git config user.name "gnew-bot"; git config user.email 
"bot@gnew.io" 
          git add k8s/services/ai-coordinator/deployment-stable.yaml 
          git commit -m "chore(canary): ai-coordinator -> ${{ 
github.event.inputs.image_tag }}" 
          git push 
 
      # Si NO usas GitOps: kubectl apply directo 
      # - uses: azure/setup-kubectl@v4 
      # - run: kubectl apply -n gnew -f 
k8s/services/ai-coordinator/deployment-stable.yaml 
      # - run: kubectl apply -n gnew -f 
k8s/services/ai-coordinator/canary.yaml 
 
 
 
 Promoci√≥n/rollback son autom√°ticos v√≠a Flagger; el workflow s√≥lo dispara el 
cambio de imagen. 
 
 
 
 Consultas r√°pidas (persistencia de 
m√©tricas) 
Ruta completa: services/release-metrics/README.md 
# Release Metrics (Canary) 
 
## Endpoints - POST `/flagger/save` ‚Üí llamado por Flagger webhook (type: event) 
  Body (metadata): 
  ```json 
  { "app": "ai-coordinator", "namespace": "gnew", "step": 3, "weight": 
30, "metricsJob": "ai-coordinator-canary" } 
 
Headers usados (si Flagger los env√≠a): 
‚óè x-flagger-phase: Progressing|Succeeded|Failed|Halted 
 
‚óè x-flagger-iteration: n¬∫ de iteraci√≥n 
‚óè x-flagger-weight: porcentaje desviado 
Queries √∫tiles 
‚óè √öltima corrida: 
SELECT * FROM "CanaryRun" WHERE app='ai-coordinator' AND "endedAt" IS 
NOT NULL ORDER BY "startedAt" DESC LIMIT 1; 
‚óè Serie por pasos: 
SELECT step, weight, "latencyP95", "errorRate" FROM "StepMetric" 
WHERE "runId" = $run ORDER BY step; --- 
# 
‚úÖ
 DoD (c√≥mo queda cubierto) - **Promoci√≥n autom√°tica condicionada**: Flagger eval√∫a **error‚Äërate** 
y **latency p95** en cada iteraci√≥n; si pasan, incrementa tr√°fico y 
**promueve**; si fallan repetidamente (`threshold`), **rollback** 
inmediato.   - **Rollback seguro**: detona con m√©tricas fuera de rango; alertas a 
Slack; Ingress vuelve a **stable** autom√°ticamente.   - **M√©tricas guardadas**: webhook `persist-metrics` llama al servicio 
**release‚Äëmetrics**, que **consulta Prometheus** y **persiste** cada 
paso (peso, p95, error‚Äërate) en Postgres.   - **Trazabilidad**: `CanaryRun` + `StepMetric` ‚Üí hist√≥rico completo 
por despliegue (fecha, iteraciones, umbrales reales).   --- 
# 
 
 
 Notas de integraci√≥n y operaci√≥n 
- Ajusta `thresholdRange` (latencia/error) a tus **SLIs** (ver N141).   - Si usas **Istio/Linkerd**, cambia `provider: istio|linkerd` y adapta 
Service/VirtualService o SMI.   - A√±ade un **segundo webhook** `confirm-rollout` si quieres una 
**aprobaci√≥n humana** antes de promover (gate manual).   - Puedes extender `release‚Äëmetrics` para guardar **CPU/mem** (PromQL 
incluidos como campos opcionales).   - Grafana: monta un panel basado en `StepMetric` (via Postgres 
datasource) + m√©tricas Prometheus en vivo. --- 
¬øQuieres que te a√±ada una **plantilla de dashboard Grafana (JSON)** y 
un **canary para otro servicio** (p. ej. `vendor-risk`) con los mismos 
umbrales? 
T√∫ dijiste: 
programa para GNEW N145 15.5 Chaos/Resiliencia (Prompt 145) Objetivo: Fault injection en 
servicios clave. Roles: SRE, Seguridad. DoD: MTTR dentro del SLO; findings integrados. 
ChatGPT Plus 
Pens√≥ durante 2m 12s 
Aqu√≠ tienes el programa a nivel de detalle y entrega para GNEW N145 ‚Äî 15.5 
Chaos/Resiliencia (Fault injection en servicios clave). Incluye: 
‚óè Kubernetes chaos con LitmusChaos (pod-kill, latency, CPU hog, DB outage 
simulada). 
‚óè Orquestador chaos-control (Node/TS + Prisma/PostgreSQL) que lanza 
experimentos, mide MTTD/MTTR v√≠a Prometheus/Synthetics y decide rollback. 
‚óè Alertas y hallazgos ‚Üí m√©tricas Prometheus, Slack/Webhook y registro de findings 
integrados. 
‚óè DoD: MTTR ‚â§ SLO por experimento; promoci√≥n/rollback seguro, con evidencias 
persistidas. 
üß©
 Orquestador de chaos (servicio 24/7) 
Ruta completa: 
services/chaos-control/package.json 
{ 
  "name": "@services/chaos-control", 
  "version": "0.1.0", 
  "private": true, 
  "type": "module", 
  "main": "dist/index.js", 
  "scripts": { 
    "dev": "tsx watch src/index.ts", 
    "build": "tsc -p tsconfig.json && tsc-alias", 
    "start": "node dist/index.js", 
    "prisma:generate": "prisma generate", 
    "prisma:migrate": "prisma migrate deploy", 
    "prisma:dev": "prisma migrate dev --name init-chaos" 
  }, 
  "dependencies": { 
    "@prisma/client": "^5.18.0", 
    "axios": "^1.7.7", 
    "dotenv": "^16.4.5", 
    "express": "^4.19.2", 
    "morgan": "^1.10.0", 
    "p-limit": "^5.0.0", 
    "prom-client": "^15.1.3", 
    "prisma": "^5.18.0", 
    "zod": "^3.23.8" 
  }, 
  "devDependencies": { 
    "@repo/typescript-config": "workspace:*", 
    "@types/express": "^4.17.21", 
    "@types/node": "^22.5.4", 
    "tsc-alias": "^1.8.10", 
    "tsx": "^4.17.0", 
    "typescript": "^5.5.4" 
} 
} 
Ruta completa: 
services/chaos-control/tsconfig.json 
{ 
} 
"extends": "@repo/typescript-config/node.json", 
"compilerOptions": { 
"rootDir": "src", 
"outDir": "dist", 
"baseUrl": "./src", 
"paths": { "@/*": ["*"] } 
}, 
"include": ["src/**/*"] 
Ruta completa: 
services/chaos-control/.env.example 
PORT=8088 
DATABASE_URL=postgresql://gnew:gnew@postgres:5432/gnew_chaos?schema=pu
 blic 
PROM_URL=http://prometheus-server.monitoring.svc.cluster.local:9090 
# M√©trica de disponibilidad de Synthetic Monitoring (Prompt 142) 
SYN_CHECK_LABEL=gateway-health 
SYN_METRIC=synthetics_check_up 
# Umbral por defecto (SLO MTTR en segundos) si el experimento no 
define uno 
DEFAULT_MTTR_SLO_SEC=300 
# Webhooks opcionales para findings/alertas 
SLACK_WEBHOOK_URL= 
FINDINGS_WEBHOOK_URL= 
# (opcional) ruta del kubeconfig dentro del contenedor si aplicas 
kubectl 
KUBECONFIG=/var/run/secrets/kubernetes.io/serviceaccount/kubeconfig 
 
Ruta completa: 
services/chaos-control/prisma/schema.prisma 
generator client { provider = "prisma-client-js" } 
datasource db { provider = "postgresql"; url = env("DATABASE_URL") } 
 
model Experiment { 
  id           String   @id @default(cuid()) 
  key          String   @unique 
  namespace    String   @default("gnew") 
  service      String   // ej. ai-coordinator 
  scenario     String   // pod-kill | net-latency | cpu-hog | 
db-outage 
  sloMttrSec   Int      @default(300) 
  severity     String   @default("MEDIUM") 
  chaosFile    String   // path YAML del ChaosEngine/CR a aplicar 
  enabled      Boolean  @default(true) 
  createdAt    DateTime @default(now()) 
  runs         Run[] 
} 
 
model Run { 
  id           String   @id @default(cuid()) 
  experimentId String 
  status       String   @default("RUNNING") // RUNNING | SUCCEEDED | 
FAILED | BREACHED | ROLLED_BACK 
  startedAt    DateTime @default(now()) 
  detectedAt   DateTime? 
  recoveredAt  DateTime? 
  mttdSec      Int? 
  mttrSec      Int? 
  notes        String? 
  experiment   Experiment @relation(fields: [experimentId], 
references: [id], onDelete: Cascade) 
  findings     Finding[] 
} 
model Finding { 
id        
String   @id @default(cuid()) 
runId     
title     
String 
String 
details   String? 
severity  String   @default("MEDIUM") 
ticketUrl String? 
createdAt DateTime @default(now()) 
run       
Run      
onDelete: Cascade) 
} 
Ruta completa: 
@relation(fields: [runId], references: [id], 
services/chaos-control/src/config.ts 
import 'dotenv/config'; 
export const cfg = { 
port: Number(process.env.PORT ?? 8088), 
promUrl: process.env.PROM_URL || 'http://prometheus:9090', 
synMetric: process.env.SYN_METRIC || 'synthetics_check_up', 
synCheckLabel: process.env.SYN_CHECK_LABEL || 'gateway-health', 
defaultMttrSlo: Number(process.env.DEFAULT_MTTR_SLO_SEC ?? 300), 
slack: process.env.SLACK_WEBHOOK_URL || '', 
findingsWebhook: process.env.FINDINGS_WEBHOOK_URL || '' 
}; 
Ruta completa: services/chaos-control/src/db.ts 
import { PrismaClient } from '@prisma/client'; 
export const prisma = new PrismaClient(); 
Ruta completa: 
services/chaos-control/src/prom.ts 
import axios from 'axios'; 
import { cfg } from './config'; 
export async function instant(query: string) { 
const { data } = await axios.get(`${cfg.promUrl}/api/v1/query`, { 
params: { query }}); 
if (data.status !== 'success') throw new Error('prom_query_failed'); 
return data.data.result; 
} 
Ruta completa: 
services/chaos-control/src/kube.ts 
import { exec } from 'node:child_process'; 
import { promisify } from 'node:util'; 
const sh = promisify(exec); 
/** 
* Aplica un manifiesto de Chaos (LitmusChaos) y devuelve salida. 
* Requiere RBAC para apply/delete de los CRDs correspondientes. 
*/ 
export async function applyChaos(filePath: string) { 
const { stdout, stderr } = await sh(`kubectl apply -f ${filePath}`); 
return { stdout, stderr }; 
} 
export async function deleteChaos(filePath: string) { 
const { stdout, stderr } = await sh(`kubectl delete -f ${filePath} --ignore-not-found`); 
return { stdout, stderr }; 
} 
Ruta completa: 
services/chaos-control/src/metrics.ts 
import client from 'prom-client'; 
export const reg = new client.Registry(); 
client.collectDefaultMetrics({ register: reg }); 
export const runs = new client.Counter({ name: 'chaos_run_total', 
help: 'Chaos runs', labelNames: ['status','scenario','service']}); 
export const mttr = new client.Histogram({ 
name: 'chaos_run_mttr_seconds', help: 'MTTR per run', labelNames: 
['scenario','service'], 
buckets: [30,60,120,180,300,450,600,900,1200,1800] 
}); 
export const mttd = new client.Histogram({ 
name: 'chaos_run_mttd_seconds', help: 'MTTD per run', labelNames: 
['scenario','service'], 
buckets: [1,2,5,10,20,30,60,120] 
}); 
reg.registerMetric(runs); 
reg.registerMetric(mttr); 
reg.registerMetric(mttd); 
export async function metricsText(){ return reg.metrics(); } 
Ruta completa: 
services/chaos-control/src/runner.ts 
import { prisma } from './db'; 
import { cfg } from './config'; 
import { instant } from './prom'; 
import { applyChaos, deleteChaos } from './kube'; 
import { runs, mttr, mttd } from './metrics'; 
import axios from 'axios'; 
async function pollAvail(check: string): Promise<number> { 
// 1 si up, 0 si down (√∫ltimo punto) 
const q = `${cfg.synMetric}{check="${check}"}`; 
const r = await instant(q); 
const v = Number(r?.[0]?.value?.[1] ?? 1); 
return v > 0.5 ? 1 : 0; 
} 
 
async function waitFor(condition: () => Promise<boolean>, timeoutMs: 
number, everyMs=3000) { 
  const until = Date.now() + timeoutMs; 
  while (Date.now() < until) { 
    if (await condition()) return true; 
    await new Promise(r => setTimeout(r, everyMs)); 
  } 
  return false; 
} 
 
async function notifyFinding(payload: any) { 
  const url = cfg.findingsWebhook || ''; 
  if (!url) return; 
  try { await axios.post(url, payload); } catch { /* ignore */ } 
} 
 
export async function triggerRun(experimentId: string) { 
  const exp = await prisma.experiment.findUnique({ where: { id: 
experimentId }}); 
  if (!exp || !exp.enabled) throw new 
Error('experiment_not_found_or_disabled'); 
 
  // 1) crear run 
  const run = await prisma.run.create({ data: { experimentId: exp.id 
}}); 
 
  // 2) validar que el check est√° UP antes de inyectar 
  const ok = await waitFor(async () => (await 
pollAvail(cfg.synCheckLabel)) === 1, 60_000, 2000); 
  if (!ok) { 
    await prisma.run.update({ where: { id: run.id }, data: { status: 
'FAILED', notes: 'precheck_down' }}); 
    runs.labels('FAILED', exp.scenario, exp.service).inc(); 
    return run; 
  } 
 
  // 3) aplicar caos 
  await applyChaos(exp.chaosFile); 
 
  // 4) esperar detecci√≥n DOWN (MTTD) 
  const detOk = await waitFor(async () => (await 
pollAvail(cfg.synCheckLabel)) === 0, 180_000, 2000); 
  let detectedAt: Date | null = null; 
  if (detOk) { 
    detectedAt = new Date(); 
    const mttdSec = Math.max(0, Math.round((detectedAt.getTime() - 
(run.startedAt as any)) / 1000)); 
    await prisma.run.update({ where: { id: run.id }, data: { 
detectedAt, mttdSec }}); 
    mttd.labels(exp.scenario, exp.service).observe(mttdSec); 
  } else { 
    // no se detect√≥ ca√≠da ‚Äî anotar finding de baja sensibilidad 
    const finding = await prisma.finding.create({ 
      data: { runId: run.id, title: 'No se detect√≥ fallo durante el 
caos', details: 'Revisar cobertura de synthetics/alertas', severity: 
'LOW' } 
    }); 
    await notifyFinding({ type: 'coverage_gap', runId: run.id, 
findingId: finding.id }); 
  } 
 
  // 5) esperar RECOVERY (UP sostenido 60s) 
  const recOk = await waitFor(async () => { 
    // pide min_over_time == 1 en 60s (usamos simple polling + 
ventana) 
    const nowUp = await pollAvail(cfg.synCheckLabel); 
    return nowUp === 1; 
  }, exp.sloMttrSec * 1000 + 300_000, 5000); 
 
  const recoveredAt = recOk ? new Date() : null; 
  const mttrSec = detectedAt && recoveredAt ? Math.max(0, 
Math.round((recoveredAt.getTime() - detectedAt.getTime())/1000)) : 
null; 
 
  // 6) decidir estado (SUCCEEDED | BREACHED) + m√©tricas 
  if (mttrSec != null) { 
    const okMttr = mttrSec <= (exp.sloMttrSec || cfg.defaultMttrSlo); 
    await prisma.run.update({ where: { id: run.id }, data: { 
      recoveredAt, mttrSec, status: okMttr ? 'SUCCEEDED' : 'BREACHED' 
    }}); 
    mttr.labels(exp.scenario, exp.service).observe(mttrSec); 
    runs.labels(okMttr ? 'SUCCEEDED' : 'BREACHED', exp.scenario, 
exp.service).inc(); 
 
    if (!okMttr) { 
      const f = await prisma.finding.create({ 
        data: { 
          runId: run.id, 
          title: `MTTR ${mttrSec}s > SLO ${exp.sloMttrSec}s`, 
          details: 'Acciones: revisar auto-healing, timeouts, circuit 
breakers, runbooks.', 
          severity: 'HIGH' 
        } 
      }); 
      await notifyFinding({ type: 'mttr_breach', runId: run.id, 
findingId: f.id, mttrSec, slo: exp.sloMttrSec }); 
    } 
  } else { 
    await prisma.run.update({ where: { id: run.id }, data: { status: 
'FAILED', notes: 'no_recovery_detected' }}); 
    runs.labels('FAILED', exp.scenario, exp.service).inc(); 
  } 
 
  // 7) rollback del caos (idempotente) 
  await deleteChaos(exp.chaosFile); 
 
  return await prisma.run.findUnique({ where: { id: run.id }, include: 
{ findings: true, experiment: true }}); 
} 
 
Ruta completa: services/chaos-control/src/app.ts 
import express from 'express'; 
import morgan from 'morgan'; 
import { prisma } from './db'; 
import { metricsText } from './metrics'; 
import { triggerRun } from './runner'; 
import { z } from 'zod'; 
 
export function createApp() { 
  const app = express(); 
  app.use(express.json()); 
  app.use(morgan('tiny')); 
 
  app.get('/healthz', (_req,res)=>res.json({status:'ok'})); 
  app.get('/metrics', async (_req,res)=>{ 
res.set('Content-Type','text/plain'); res.send(await metricsText()); 
}); 
 
  // Experimentos 
  app.post('/admin/experiment', async (req,res,next)=>{ try { 
    const s = z.object({ 
      key: z.string(), namespace: z.string().default('gnew'), 
      service: z.string(), scenario: z.string(), 
      sloMttrSec: z.number().int().positive().default(300), 
      severity: z.string().default('MEDIUM'), 
      chaosFile: z.string(), enabled: z.boolean().default(true) 
    }).parse(req.body); 
    const r = await prisma.experiment.upsert({ 
      where: { key: s.key }, 
      update: { ...s }, 
      create: { ...s } 
    }); 
    res.json(r); 
  } catch(e){ next(e);} }); 
 
  // Lanzar una ejecuci√≥n 
  app.post('/runs/trigger/:key', async (req,res,next)=>{ try { 
    const exp = await prisma.experiment.findUnique({ where: { key: 
req.params.key }}); 
if (!exp) return res.status(404).json({ error: 
'experiment_not_found' }); 
const r = await triggerRun(exp.id); 
res.json(r); 
} catch(e){ next(e);} }); 
app.get('/runs/:id', async (req,res)=> res.json(await 
prisma.run.findUnique({ where: { id: req.params.id }, include: { 
findings: true, experiment: true }}))); 
// error 
app.use((err:any,_req:any,res:any,_next:any)=>{ console.error(err); 
res.status(400).json({ error: err.message || 'bad_request' }); }); 
return app; 
} 
Ruta completa: 
services/chaos-control/src/index.ts 
import { createApp } from './app'; 
const port = Number(process.env.PORT ?? 8088); 
createApp().listen(port, ()=>console.log(`[chaos-control] :${port}`)); 
Ruta completa: services/chaos-control/Dockerfile 
FROM node:20-alpine AS deps 
WORKDIR /app 
COPY package.json package-lock.json* pnpm-lock.yaml* yarn.lock* ./ 
RUN --mount=type=cache,target=/root/.npm npm ci || npm i 
FROM node:20-alpine AS build 
WORKDIR /app 
COPY --from=deps /app/node_modules ./node_modules 
COPY . . 
RUN npm run prisma:generate 
RUN npm run build && npx tsc-alias 
FROM node:20-alpine 
WORKDIR /app 
ENV NODE_ENV=production 
RUN apk add --no-cache bash curl ca-certificates kubectl 
COPY --from=build /app/node_modules ./node_modules 
COPY --from=build /app/dist ./dist 
COPY --from=build /app/prisma ./prisma 
COPY --from=build /app/package.json . 
EXPOSE 8088 
HEALTHCHECK --interval=30s --timeout=3s CMD wget -qO- 
http://localhost:8088/healthz || exit 1 
CMD ["node","dist/index.js"] 
‚öí
 Manifiestos de Chaos (LitmusChaos) 
Si a√∫n no tienes Litmus instalado, despliega su operador por Helm (cluster‚Äëwide) y 
otorga RBAC al namespace gnew. Los CRs siguientes son ejemplos listos para 
kubectl apply. 
Ruta completa: 
k8s/chaos/litmus/namespace-rbac.yaml 
apiVersion: v1 
kind: Namespace 
metadata: { name: gnew } --- 
apiVersion: v1 
kind: ServiceAccount 
metadata: { name: litmus-runner, namespace: gnew } --- 
apiVersion: rbac.authorization.k8s.io/v1 
kind: Role 
metadata: { name: litmus-runner, namespace: gnew } 
rules: - apiGroups: ["","apps","extensions"] 
    resources: 
["pods","pods/log","deployments","replicasets","events"] 
    verbs: ["create","list","get","update","patch","delete","watch"] 
  - apiGroups: ["litmuschaos.io"] 
    resources: ["chaosengines","chaosexperiments","chaosresults"] 
    verbs: ["create","list","get","update","patch","delete","watch"] --- 
apiVersion: rbac.authorization.k8s.io/v1 
kind: RoleBinding 
metadata: { name: litmus-runner, namespace: gnew } 
subjects: 
  - kind: ServiceAccount 
    name: litmus-runner 
    namespace: gnew 
roleRef: 
  kind: Role 
  name: litmus-runner 
  apiGroup: rbac.authorization.k8s.io 
 
Ruta completa: 
k8s/chaos/experiments/pod-kill-ai-coordinator
 .yaml 
apiVersion: litmuschaos.io/v1alpha1 
kind: ChaosEngine 
metadata: 
  name: ai-coordinator-pod-kill 
  namespace: gnew 
spec: 
  appinfo: 
    appns: gnew 
    applabel: "app=ai-coordinator" 
    appkind: deployment 
  chaosServiceAccount: litmus-runner 
  experiments: 
    - name: pod-delete 
      spec: 
        components: 
          env: 
            - name: TARGET_CONTAINER 
              value: "api" 
            - name: CHAOS_INTERVAL 
              value: "10" 
            - name: TOTAL_CHAOS_DURATION 
              value: "60" 
 
Ruta completa: 
k8s/chaos/experiments/net-latency-ai-coordina
 tor.yaml 
apiVersion: litmuschaos.io/v1alpha1 
kind: ChaosEngine 
metadata: 
  name: ai-coordinator-net-latency 
  namespace: gnew 
spec: 
  appinfo: 
    appns: gnew 
    applabel: "app=ai-coordinator" 
    appkind: deployment 
  chaosServiceAccount: litmus-runner 
  experiments: 
    - name: pod-network-latency 
      spec: 
        components: 
          env: 
            - name: NETWORK_INTERFACE 
              value: eth0 
            - name: LATENCY 
              value: "300"   # ms 
            - name: JITTER 
              value: "50" 
            - name: TOTAL_CHAOS_DURATION 
              value: "120" 
 
Ruta completa: 
k8s/chaos/experiments/cpu-hog-ai-coordinator.
 yaml 
apiVersion: litmuschaos.io/v1alpha1 
kind: ChaosEngine 
metadata: 
  name: ai-coordinator-cpu-hog 
  namespace: gnew 
spec: 
  appinfo: 
    appns: gnew 
    applabel: "app=ai-coordinator" 
    appkind: deployment 
  chaosServiceAccount: litmus-runner 
  experiments: 
    - name: pod-cpu-hog 
      spec: 
        components: 
          env: 
            - name: CPU_CORES 
              value: "2" 
            - name: TOTAL_CHAOS_DURATION 
              value: "90" 
 
Ruta completa: 
k8s/chaos/experiments/db-outage-postgres.yaml 
apiVersion: litmuschaos.io/v1alpha1 
kind: ChaosEngine 
metadata: 
  name: postgres-outage 
  namespace: gnew 
spec: 
  appinfo: 
    appns: gnew 
    applabel: "app=postgres" 
    appkind: statefulset 
  chaosServiceAccount: litmus-runner 
  experiments: 
    - name: pod-delete 
      spec: 
        components: 
          env: 
            - name: FORCE 
              value: "true" 
            - name: TOTAL_CHAOS_DURATION 
              value: "60" 
 
 
 
 
 Cat√°logo de experimentos (para 
chaos-control) 
Ruta completa: 
services/chaos-control/experiments/catalog.js
 on 
[ 
  { 
    "key": "ai-pod-kill", 
    "namespace": "gnew", 
    "service": "ai-coordinator", 
    "scenario": "pod-kill", 
    "sloMttrSec": 300, 
    "severity": "MEDIUM", 
    "chaosFile": "k8s/chaos/experiments/pod-kill-ai-coordinator.yaml", 
    "enabled": true 
  }, 
  { 
    "key": "ai-net-latency", 
    "namespace": "gnew", 
    "service": "ai-coordinator", 
    "scenario": "net-latency", 
    "sloMttrSec": 300, 
    "severity": "MEDIUM", 
    "chaosFile": 
"k8s/chaos/experiments/net-latency-ai-coordinator.yaml", 
    "enabled": true 
  }, 
  { 
    "key": "ai-cpu-hog", 
    "namespace": "gnew", 
    "service": "ai-coordinator", 
    "scenario": "cpu-hog", 
    "sloMttrSec": 300, 
    "severity": "LOW", 
    "chaosFile": "k8s/chaos/experiments/cpu-hog-ai-coordinator.yaml", 
    "enabled": true 
  }, 
  { 
    "key": "db-outage", 
    "namespace": "gnew", 
    "service": "postgres", 
    "scenario": "db-outage", 
    "sloMttrSec": 600, 
    "severity": "HIGH", 
    "chaosFile": "k8s/chaos/experiments/db-outage-postgres.yaml", 
    "enabled": true 
  } 
] 
 
 
 
 
 Alertas Prometheus (MTTR, brechas, 
runs) 
Ruta completa: 
tools/monitoring/prometheus/chaos.rules.yml 
groups: 
  - name: chaos-recording 
    rules: 
      - record: chaos:mttr_p50 
        expr: histogram_quantile(0.50, 
sum(rate(chaos_run_mttr_seconds_bucket[15m])) by 
(le,scenario,service)) 
      - record: chaos:mttr_p90 
        expr: histogram_quantile(0.90, 
sum(rate(chaos_run_mttr_seconds_bucket[15m])) by 
(le,scenario,service)) 
      - record: chaos:mttd_p90 
        expr: histogram_quantile(0.90, 
sum(rate(chaos_run_mttd_seconds_bucket[15m])) by 
(le,scenario,service)) 
 
Ruta completa: 
tools/monitoring/prometheus/chaos.alerts.yml 
groups: 
  - name: chaos-alerts 
    rules: 
      - alert: ChaosMTTRBreached 
        expr: chaos:mttr_p90 > 300 
        for: 10m 
        labels: { severity: critical } 
        annotations: 
          summary: "MTTR p90 sobre SLO ({{ $labels.service }} / {{ 
$labels.scenario }})" 
          description: "Revisi√≥n de auto-healing/runbooks requerida." 
      - alert: ChaosRunFailed 
        expr: 
increase(chaos_run_total{status=~"FAILED|BREACHED"}[30m]) > 0 
        for: 5m 
        labels: { severity: warning } 
        annotations: 
          summary: "Chaos runs con fallo/breach recientes" 
          description: "Ver detalles en servicio chaos-control / 
findings." 
 
 
 
 
 CI de resiliencia (gatillo diario y bajo 
demanda) 
Ruta completa: .github/workflows/chaos.yml 
name: Chaos Resilience 
 
on: 
  schedule: 
    - cron: "0 3 * * *"  # diario en staging 
  workflow_dispatch: 
    inputs: 
      experiment_key: 
        description: "Key del experimento (opcional)" 
        required: false 
 
jobs: 
  run-chaos: 
    runs-on: ubuntu-latest 
    steps: 
      - uses: actions/checkout@v4 
      - name: Trigger chaos (all or single) 
        env: 
          CHAOS_URL: ${{ vars.CHAOS_URL || 'https://chaos.gnew.io' }} 
          TOKEN: ${{ secrets.CHAOS_TOKEN || '' }} 
        run: | 
          if [ -n "${{ github.event.inputs.experiment_key }}" ]; then 
            curl -fsS -X POST -H "Authorization: Bearer $TOKEN" \ 
              -H "Content-Type: application/json" \ 
              "$CHAOS_URL/runs/trigger/${{ 
github.event.inputs.experiment_key }}" 
          else 
            # por simplicidad: dispara los 4 de cat√°logo 
            for k in ai-pod-kill ai-net-latency ai-cpu-hog db-outage; 
do 
              curl -fsS -X POST "$CHAOS_URL/runs/trigger/$k" || true 
            done 
          fi 
 
 
 
 
 README / Runbook 
Ruta completa: services/chaos-control/README.md 
# Chaos Control (GNEW N145) 
 
Orquesta experimentos de caos (LitmusChaos) y mide MTTD/MTTR con 
Prometheus + Synthetics. 
 
## Endpoints - `POST /admin/experiment` ‚Üí upsert de experimento (ver catalog.json) - `POST /runs/trigger/:key` ‚Üí lanza un run, aplica el manifiesto YAML 
y mide MTTD/MTTR - `GET /runs/:id` ‚Üí detalles del run + findings - `GET /metrics` ‚Üí m√©tricas Prometheus (runs, mttd, mttr) - `GET /healthz` 
 
## Definiciones - **MTTD**: tiempo desde inicio del caos hasta 1er 
`synthetics_check_up{check=...}=0` - **MTTR**: tiempo desde detecci√≥n (down) hasta recuperaci√≥n `=1` 
sostenida - **SLO MTTR**: por experimento (campo `sloMttrSec`), default `.env` 
 
## Operaci√≥n 
1. Instala LitmusChaos en el cluster y aplica 
`k8s/chaos/litmus/namespace-rbac.yaml`. 
2. Registra experimentos con `/admin/experiment` (o importa 
`experiments/catalog.json`). 
3. Asegura que `services/synthetics` monitorea **la misma ruta 
cr√≠tica** (`SYN_CHECK_LABEL`). 
4. Ejecuta `/runs/trigger/:key` (manual o por CI). 
5. Revisa resultados y findings (Slack/Webhook + DB). 
## Seguridad - RBAC m√≠nimo para aplicar/eliminar ChaosEngine en `gnew`. - No ejecutar caos destructivo en **prod** salvo ventana y aprobaci√≥n. 
‚úÖ
 C√≥mo se cumple el DoD 
‚óè MTTR dentro del SLO: el orquestador calcula MTTD/MTTR por run; reglas/alertas 
Prometheus y estado del run (SUCCEEDED, BREACHED, FAILED). 
‚óè Rollback seguro: cada run elimina el ChaosEngine al finalizar; si BREACHED o 
FAILED, queda evidencia y alerta, sin prolongar el fallo. 
‚óè Findings integrados: tabla Finding, webhook opcional (FINDINGS_WEBHOOK_URL) y 
Slack; cada brecha genera un hallazgo accionable con contexto (SLO vs MTTR). 
‚óè Resiliencia continua: CI diario (staging) + ejecuci√≥n on‚Äëdemand; cat√°logo de 
escenarios (pod‚Äëkill, net‚Äëlatency, CPU hog, DB outage). 
¬øQuieres que a√±ada un dashboard Grafana (JSON) de MTTD/MTTR por servicio/escenario 
y un experimento de caos espec√≠fico de seguridad (p. ej., cert expirado o secrets rotated) 
con controles para no exponer datos? 
T√∫ dijiste: 
continua programando a profundidad para gnew N146 15.6 Error Budgets & SLOs (Prompt 146) 
Objetivo: Gesti√≥n activa de error budget. Roles: SRE, Producto. DoD: gates ‚Äúfreeze deploys‚Äù 
cuando se excede. 
ChatGPT Plus 
Pens√≥ durante 2m 12s 
Aqu√≠ tienes el programa a nivel de detalle y entrega para GNEW N146 ‚Äî 15.6 Error 
Budgets & SLOs (Gesti√≥n activa de error budget). Incluye un servicio ‚Äúslo-budget‚Äù 
(Node/TypeScript + Prisma + Prometheus) que: 
‚óè Calcula SLI/SLO con PromQL (ventanas m√∫ltiples). 
 
‚óè Mide y persiste budget remaining y burn rates. 
 
‚óè Decide ‚Äúfreeze deploys‚Äù autom√°ticamente seg√∫n pol√≠ticas (multi‚Äëwindow burn + umbral 
de presupuesto). 
 
‚óè Expone un ‚Äúgate‚Äù para CI/CD (GitHub Actions / ArgoCD PreSync) que bloquea 
despliegues al exceder el presupuesto. 
 
‚óè Emite m√©tricas Prometheus y notificaciones (Slack/Webhook). 
 
‚óè DoD: ‚Äúfreeze deploys‚Äù efectivo cuando se excede el presupuesto. 
 
 
 
 
 Servicio: services/slo-budget 
Ruta completa: services/slo-budget/package.json 
{ 
  "name": "@services/slo-budget", 
  "version": "0.1.0", 
  "private": true, 
  "type": "module", 
  "main": "dist/index.js", 
  "scripts": { 
    "dev": "tsx watch src/index.ts", 
    "build": "tsc -p tsconfig.json && tsc-alias", 
    "start": "node dist/index.js", 
    "prisma:generate": "prisma generate", 
    "prisma:migrate": "prisma migrate deploy", 
    "prisma:dev": "prisma migrate dev --name init-slo" 
  }, 
  "dependencies": { 
    "@prisma/client": "^5.18.0", 
    "axios": "^1.7.7", 
    "dotenv": "^16.4.5", 
    "express": "^4.19.2", 
    "morgan": "^1.10.0", 
    "p-limit": "^5.0.0", 
    "prom-client": "^15.1.3", 
    "prisma": "^5.18.0", 
    "yaml": "^2.5.0", 
    "zod": "^3.23.8" 
  }, 
  "devDependencies": { 
    "@repo/typescript-config": "workspace:*", 
    "@types/express": "^4.17.21", 
    "@types/node": "^22.5.4", 
    "tsc-alias": "^1.8.10", 
    "tsx": "^4.17.0", 
    "typescript": "^5.5.4" 
  } 
} 
 
Ruta completa: services/slo-budget/tsconfig.json 
{ 
  "extends": "@repo/typescript-config/node.json", 
  "compilerOptions": { 
    "rootDir": "src", 
    "outDir": "dist", 
    "baseUrl": "./src", 
    "paths": { "@/*": ["*"] } 
  }, 
  "include": ["src/**/*"] 
} 
 
Ruta completa: services/slo-budget/.env.example 
PORT=8089 
DATABASE_URL=postgresql://gnew:gnew@postgres:5432/gnew_slo?schema=publ
 ic 
PROM_URL=http://prometheus-server.monitoring.svc.cluster.local:9090 
# Notificaciones (opcionales) 
SLACK_WEBHOOK_URL= 
ALERT_WEBHOOK_URL= 
# Scheduler 
EVAL_INTERVAL_SEC=60 
# Defaults (si un SLO no define expl√≠cito) 
DEFAULT_WINDOW_DAYS=30 
DEFAULT_TARGET=0.999      
# 99.9% 
DEFAULT_MIN_REMAINING=0.2 # 20% de budget restante 
DEFAULT_FAST_BURN=14.4    
# recomendado (fast window) 
DEFAULT_SLOW_BURN=6       
# recomendado (slow window) 
 
 
 Datos (Prisma) 
Ruta completa: services/slo-budget/prisma/schema.prisma 
generator client { provider = "prisma-client-js" } 
datasource db { provider = "postgresql"; url = env("DATABASE_URL") } 
model SLO { 
id           
key          
service      
env          
String   @id @default(cuid()) 
String   @unique 
String 
String   @default("staging") 
description  String? 
// objetivo 
target       
Float    
windowDays   Int      
@default(0.999) // 0..1 
@default(30)    
// rolling window 
// expresiones PromQL con placeholder $window (ej: 30d, 6h, 1h) 
  goodExpr     String   // ej: 
sum(increase(http_server_request_duration_seconds_count{job="ai-coordi
 nator",status!~"5.."}[$window])) 
  totalExpr    String   // ej: 
sum(increase(http_server_request_duration_seconds_count{job="ai-coordi
 nator"}[$window])) 
  // pol√≠tica de freeze 
  minRemaining Float    @default(0.2)   // 0..1 
  fastWin      String   @default("1h") 
  slowWin      String   @default("6h") 
  fastBurn     Float    @default(14.4) 
  slowBurn     Float    @default(6.0) 
  // estado actual 
  frozen       Boolean  @default(false) 
  freezeReason String? 
  updatedAt    DateTime @updatedAt 
  createdAt    DateTime @default(now()) 
 
  snapshots    Snapshot[] 
} 
 
model Snapshot { 
  id          String   @id @default(cuid()) 
  sloId       String 
  ts          DateTime @default(now()) 
  // m√©tricas calculadas 
  sli          Float 
  errFraction  Float 
  budgetRemain Float   // 0..1 
  burnFast     Float 
  burnSlow     Float 
  decision     String  // OK|WARN|FREEZE 
  slo          SLO     @relation(fields: [sloId], references: [id], 
onDelete: Cascade) 
 
  @@index([sloId, ts]) 
} 
 
 
üîß
 C√≥digo del servicio 
Ruta completa: services/slo-budget/src/config.ts 
import 'dotenv/config'; 
 
export const cfg = { 
  port: Number(process.env.PORT ?? 8089), 
  prom: process.env.PROM_URL || 'http://prometheus:9090', 
  evalIntervalSec: Number(process.env.EVAL_INTERVAL_SEC ?? 60), 
  defaults: { 
    windowDays: Number(process.env.DEFAULT_WINDOW_DAYS ?? 30), 
    target: Number(process.env.DEFAULT_TARGET ?? 0.999), 
    minRemaining: Number(process.env.DEFAULT_MIN_REMAINING ?? 0.2), 
    fastBurn: Number(process.env.DEFAULT_FAST_BURN ?? 14.4), 
    slowBurn: Number(process.env.DEFAULT_SLOW_BURN ?? 6.0) 
  }, 
  webhooks: { 
    slack: process.env.SLACK_WEBHOOK_URL || '', 
    alt: process.env.ALERT_WEBHOOK_URL || '' 
  } 
}; 
 
Ruta completa: services/slo-budget/src/db.ts 
import { PrismaClient } from '@prisma/client'; 
export const prisma = new PrismaClient(); 
 
Ruta completa: services/slo-budget/src/prom.ts 
import axios from 'axios'; 
import { cfg } from './config'; 
 
export async function promInstant(query: string) { 
  const { data } = await axios.get(`${cfg.prom}/api/v1/query`, { 
params: { query }}); 
  if (data.status !== 'success') throw new Error('prom_query_failed'); 
  return data.data.result; 
} 
// eval√∫a un escalar (toma el primer valor) 
export async function promScalar(query: string): Promise<number> { 
const r = await promInstant(query); 
const v = Number(r?.[0]?.value?.[1] ?? 0); 
return Number.isFinite(v) ? v : 0; 
} 
Ruta completa: services/slo-budget/src/notify.ts 
import axios from 'axios'; 
import { cfg } from './config'; 
export async function notify(payload: any) { 
const urls = [cfg.webhooks.slack, cfg.webhooks.alt].filter(Boolean); 
await Promise.all(urls.map(u => axios.post(u, 
payload).catch(()=>{}))); 
} 
Ruta completa: services/slo-budget/src/metrics.ts 
import client from 'prom-client'; 
export const reg = new client.Registry(); 
client.collectDefaultMetrics({ register: reg }); 
export const gauges = { 
budgetRemaining: new client.Gauge({ name: 'slo_budget_remaining', 
help: 'Budget remaining 0..1', labelNames: ['slo','service','env'] }), 
burnFast: new client.Gauge({ name: 'slo_burn_rate_fast', help: 
'Fast-window burn rate', labelNames: ['slo','service','env'] }), 
burnSlow: new client.Gauge({ name: 'slo_burn_rate_slow', help: 
'Slow-window burn rate', labelNames: ['slo','service','env'] }), 
frozen: new client.Gauge({ name: 'slo_frozen', help: '1 if frozen', 
labelNames: ['slo','service','env','reason'] }) 
}; 
Object.values(gauges).forEach(g => reg.registerMetric(g)); 
export async function metricsText(){ return reg.metrics(); } 
Ruta completa: services/slo-budget/src/types.ts 
export type EvalInput = { 
target: number; windowDays: number; 
goodExpr: string; totalExpr: string; 
fastWin: string; slowWin: string; 
fastBurn: number; slowBurn: number; 
minRemaining: number; 
}; 
export type EvalResult = { 
sli: number; errFraction: number; budgetRemain: number; 
burnFast: number; burnSlow: number; decision: 'OK'|'WARN'|'FREEZE'; 
}; 
Ruta completa: services/slo-budget/src/evaluator.ts 
import { promScalar } from './prom'; 
import { EvalInput, EvalResult } from './types'; 
// helper: construye consultas sustituyendo $window 
function build(expr: string, window: string) { 
return expr.replaceAll('$window', window); 
} 
// calcula SLI, error fraction y burn rates (fast/slow) 
export async function evaluate(input: EvalInput): Promise<EvalResult> 
{ 
const window = `${input.windowDays}d`; 
const [good, total] = await Promise.all([ 
promScalar(build(input.goodExpr, window)), 
promScalar(build(input.totalExpr, window)) 
]); 
const sli = total > 0 ? good / total : 1.0; 
const errFraction = Math.max(0, 1 - sli); 
const budgetAllowed = Math.max(1e-12, 1 - input.target); 
  const budgetRemain = Math.max(0, 1 - (errFraction / budgetAllowed)); 
// 1 -> 0, 0 -> agotado 
 
  // burn rates 
  const [goodF, totalF, goodS, totalS] = await Promise.all([ 
    promScalar(build(input.goodExpr, input.fastWin)), 
    promScalar(build(input.totalExpr, input.fastWin)), 
    promScalar(build(input.goodExpr, input.slowWin)), 
    promScalar(build(input.totalExpr, input.slowWin)) 
  ]); 
  const burnFast = (totalF>0) ? ((1 - (goodF/totalF)) / budgetAllowed) 
: 0; 
  const burnSlow = (totalS>0) ? ((1 - (goodS/totalS)) / budgetAllowed) 
: 0; 
 
  // decisi√≥n 
  let decision: EvalResult['decision'] = 'OK'; 
  if (budgetRemain <= input.minRemaining) decision = 'FREEZE'; 
  if (burnFast >= input.fastBurn && burnSlow >= input.slowBurn) 
decision = 'FREEZE'; 
  if (decision === 'OK' && (burnFast >= input.fastBurn || burnSlow >= 
input.slowBurn)) decision = 'WARN'; 
 
  return { sli: round4(sli), errFraction: round4(errFraction), 
budgetRemain: round4(budgetRemain), 
           burnFast: round4(burnFast), burnSlow: round4(burnSlow), 
decision }; 
} 
 
const round4 = (n:number)=> Number((n).toFixed(4)); 
 
Ruta completa: services/slo-budget/src/controllers.ts 
import { prisma } from './db'; 
import { evaluate } from './evaluator'; 
import { gauges } from './metrics'; 
import { notify } from './notify'; 
 
export async function upsertSLO(input: any) { 
  const slo = await prisma.sLO.upsert({ 
    where: { key: input.key }, 
    update: { ...input }, 
    create: { ...input } 
  }); 
  return slo; 
} 
 
export async function listSLOs() { 
  return prisma.sLO.findMany({ orderBy: { createdAt: 'desc' }}); 
} 
 
export async function getSLO(key: string) { 
  return prisma.sLO.findUnique({ where: { key }}); 
} 
 
export async function evalAndPersist(sloId: string) { 
  const slo = await prisma.sLO.findUnique({ where: { id: sloId }}); 
  if (!slo) throw new Error('slo_not_found'); 
 
  const res = await evaluate({ 
    target: slo.target, windowDays: slo.windowDays, 
    goodExpr: slo.goodExpr, totalExpr: slo.totalExpr, 
    fastWin: slo.fastWin, slowWin: slo.slowWin, 
    fastBurn: slo.fastBurn, slowBurn: slo.slowBurn, 
    minRemaining: slo.minRemaining 
  }); 
 
  // metrics 
  gauges.budgetRemaining.labels(slo.key, slo.service, 
slo.env).set(res.budgetRemain); 
  gauges.burnFast.labels(slo.key, slo.service, 
slo.env).set(res.burnFast); 
  gauges.burnSlow.labels(slo.key, slo.service, 
slo.env).set(res.burnSlow); 
 
  // FREEZE/UNFREEZE 
  let newFrozen = slo.frozen; 
  let reason: string | null = slo.freezeReason ?? null; 
 
  if (res.decision === 'FREEZE' && !slo.frozen) { 
    newFrozen = true; 
    reason = freezeReason(res); 
    await notify({ type: 'slo_freeze', slo: slo.key, service: 
slo.service, env: slo.env, reason, snapshot: res }); 
  } else if (res.decision === 'OK' && slo.frozen) { 
    newFrozen = false; 
    reason = null; 
    await notify({ type: 'slo_unfreeze', slo: slo.key, service: 
slo.service, env: slo.env, snapshot: res }); 
  } 
 
  if (newFrozen !== slo.frozen || reason !== slo.freezeReason) { 
    await prisma.sLO.update({ where: { id: slo.id }, data: { frozen: 
newFrozen, freezeReason: reason ?? undefined }}); 
  } 
  gauges.frozen.labels(slo.key, slo.service, slo.env, reason ?? 
'').set(newFrozen ? 1 : 0); 
 
  // snapshot 
  await prisma.snapshot.create({ 
    data: { 
      sloId: slo.id, 
      sli: res.sli, 
      errFraction: res.errFraction, 
      budgetRemain: res.budgetRemain, 
      burnFast: res.burnFast, 
      burnSlow: res.burnSlow, 
      decision: res.decision 
    } 
  }); 
 
  return { slo, res }; 
} 
 
function freezeReason(r: { budgetRemain:number; burnFast:number; 
burnSlow:number }): string { 
if (r.budgetRemain <= 0) return 'budget_depleted'; 
if (r.burnFast >=  r.burnSlow) return `burn_fast:${r.burnFast}`; 
return `burn_slow:${r.burnSlow}`; 
} 
export async function gate(key: string) { 
const slo = await prisma.sLO.findUnique({ where: { key }}); 
if (!slo) throw new Error('slo_not_found'); 
if (slo.frozen) return { allowed: false, reason: slo.freezeReason || 
'frozen' }; 
return { allowed: true }; 
} 
Ruta completa: services/slo-budget/src/app.ts 
import express from 'express'; 
import morgan from 'morgan'; 
import { z } from 'zod'; 
import { metricsText } from './metrics'; 
import * as ctrl from './controllers'; 
import { prisma } from './db'; 
import { cfg } from './config'; 
export function createApp() { 
const app = express(); 
app.use(express.json()); 
app.use(morgan('tiny')); 
app.get('/healthz', (_req,res)=>res.json({status:'ok'})); 
app.get('/metrics', async (_req,res)=>{ 
res.set('Content-Type','text/plain'); res.send(await metricsText()); 
}); 
// admin: alta/edici√≥n de SLO 
app.post('/admin/slo', async (req,res,next)=>{ try { 
const S = z.object({ 
      key: z.string(), service: z.string(), env: 
z.string().default('staging'), 
      description: z.string().optional(), 
      target: 
z.number().min(0.5).max(0.99999).default(cfg.defaults.target), 
      windowDays: 
z.number().int().positive().default(cfg.defaults.windowDays), 
      goodExpr: z.string(), totalExpr: z.string(), 
      minRemaining: 
z.number().min(0).max(1).default(cfg.defaults.minRemaining), 
      fastWin: z.string().default('1h'), slowWin: 
z.string().default('6h'), 
      fastBurn: z.number().positive().default(cfg.defaults.fastBurn), 
      slowBurn: z.number().positive().default(cfg.defaults.slowBurn) 
    }); 
    const slo = await ctrl.upsertSLO(S.parse(req.body)); 
    res.json(slo); 
  } catch(e){ next(e);} }); 
 
  app.get('/slos', async (_req,res)=> res.json(await 
ctrl.listSLOs())); 
  app.get('/slos/:key', async (req,res)=> res.json(await 
ctrl.getSLO(req.params.key))); 
 
  // eval on demand 
  app.post('/eval/:key', async (req,res,next)=>{ try { 
    const slo = await ctrl.getSLO(req.params.key); 
    if (!slo) return res.status(404).json({ error: 'slo_not_found' }); 
    res.json(await ctrl.evalAndPersist(slo.id)); 
  } catch(e){ next(e);} }); 
 
  // gate para CI/CD ‚Äî 200 OK = permitido; 423 Locked = freeze 
  app.get('/gate/:key', async (req,res,next)=>{ try { 
    const g = await ctrl.gate(req.params.key); 
    if (!g.allowed) return res.status(423).json(g); 
    return res.json(g); 
  } catch(e){ next(e);} }); 
 
// scheduler 
setInterval(async ()=> { 
try { 
const slos = await prisma.sLO.findMany({ select: { id: true }}); 
await 
Promise.allSettled(slos.map(s=>ctrl.evalAndPersist(s.id))); 
} catch {} 
}, cfg.evalIntervalSec * 1000); 
// error 
app.use((err:any,_req:any,res:any,_next:any)=>{ console.error(err); 
res.status(400).json({ error: err.message || 'bad_request' }); }); 
return app; 
} 
Ruta completa: services/slo-budget/src/index.ts 
import { createApp } from './app'; 
import { cfg } from './config'; 
createApp().listen(cfg.port, ()=>console.log(`[slo-budget] 
:${cfg.port}`)); 
Ruta completa: services/slo-budget/Dockerfile 
FROM node:20-alpine AS deps 
WORKDIR /app 
COPY package.json package-lock.json* pnpm-lock.yaml* yarn.lock* 
.npmrc* ./ 
RUN --mount=type=cache,target=/root/.npm npm ci || npm i 
FROM node:20-alpine AS build 
WORKDIR /app 
COPY --from=deps /app/node_modules ./node_modules 
COPY . . 
RUN npm run prisma:generate 
RUN npm run build && npx tsc-alias 
FROM node:20-alpine 
WORKDIR /app 
ENV NODE_ENV=production 
COPY --from=build /app/node_modules ./node_modules 
COPY --from=build /app/dist ./dist 
COPY --from=build /app/prisma ./prisma 
COPY --from=build /app/package.json . 
EXPOSE 8089 
HEALTHCHECK --interval=30s --timeout=3s CMD wget -qO- 
http://localhost:8089/healthz || exit 1 
CMD ["node","dist/index.js"] 
 
 
 Cat√°logo de SLOs (ejemplos) 
Ruta completa: services/slo-budget/slo-catalog.yaml - key: ai-api-availability 
service: ai-coordinator 
env: staging 
description: "Disponibilidad API (5xx excluidos) objetivo 99.9% / 
30d" 
target: 0.999 
windowDays: 30 
goodExpr: | 
sum(increase(http_server_request_duration_seconds_count{job="ai-coordi
 nator",status!~"5.."}[$window])) 
totalExpr: | 
sum(increase(http_server_request_duration_seconds_count{job="ai-coordi
 nator"}[$window])) 
minRemaining: 0.2 
fastWin: 1h 
slowWin: 6h 
fastBurn: 14.4 
slowBurn: 6 - key: ai-api-latency-500ms 
service: ai-coordinator 
  env: staging 
  description: "Latencia p50<=0.5s aproximada por porcentaje <=0.5s" 
  target: 0.95 
  windowDays: 30 
  goodExpr: | 
    
sum(increase(http_server_request_duration_seconds_bucket{job="ai-coord
 inator",le="0.5"}[$window])) 
  totalExpr: | 
    
sum(increase(http_server_request_duration_seconds_count{job="ai-coordi
 nator"}[$window])) 
  minRemaining: 0.25 
  fastWin: 30m 
  slowWin: 2h 
  fastBurn: 10 
  slowBurn: 4 
 
Carga estos objetos v√≠a POST /admin/slo (puedes hacer un script que lea YAML 
y los suba). 
 
 
 
 Gate de despliegue ‚Äî GitHub Actions 
Ruta completa: .github/workflows/slo-freeze-gate.yml 
name: SLO Freeze Gate 
 
on: 
  pull_request: 
    branches: [ main ] 
  workflow_dispatch: {} 
 
jobs: 
  check-slo-gate: 
    runs-on: ubuntu-latest 
    steps: 
      - name: Check SLOs before deploy 
        env: 
          SLO_URL: ${{ vars.SLO_BUDGET_URL || 'https://slo.gnew.io' }} 
        run: | 
          set -e 
          # a√±ade tantas claves SLO como necesites gatear 
          KEYS=("ai-api-availability" "ai-api-latency-500ms") 
          BLOCK=0 
          for k in "${KEYS[@]}"; do 
            echo "Checking $k ..." 
            code=$(curl -s -o resp.json -w "%{http_code}" 
"$SLO_URL/gate/$k" || echo 500) 
            cat resp.json || true 
            if [ "$code" != "200" ]; then 
              echo "::error ::SLO gate failed for $k (HTTP $code)" 
              BLOCK=1 
            fi 
          done 
          if [ $BLOCK -eq 1 ]; then 
            echo "Freezing deploys due to SLO gate." 
            exit 1 
          fi 
 
Este job falla el PR/Deploy si el servicio devuelve 423 Locked, cumpliendo el 
‚Äúfreeze deploys‚Äù. 
 
 
 
 Gate para ArgoCD (PreSync Hook) 
Ruta completa: k8s/hooks/argocd-presync-slo-gate.yaml 
apiVersion: batch/v1 
kind: Job 
metadata: 
  name: presync-slo-gate 
  namespace: gnew 
  annotations: 
    argocd.argoproj.io/hook: PreSync 
    argocd.argoproj.io/hook-delete-policy: HookSucceeded 
spec: 
  template: 
    spec: 
      restartPolicy: Never 
      containers: 
        - name: gate 
          image: curlimages/curl:8.8.0 
          args: 
            - /bin/sh 
            - -lc 
            - | 
              set -e 
              
SLO_URL=${SLO_URL:-http://slo-budget.gnew.svc.cluster.local:8089} 
              for k in ai-api-availability ai-api-latency-500ms; do 
                echo "Gate $k" 
                code=$(curl -s -o /dev/null -w "%{http_code}" 
"$SLO_URL/gate/$k" || echo 500) 
                [ "$code" = "200" ] || { echo "Freeze due to $k"; exit 
1; } 
              done 
 
 
 
 
 Reglas Prometheus (opcional, visibilidad adicional) 
Ruta completa: tools/monitoring/prometheus/slo.alerts.yml 
groups: 
  - name: slo-burn 
    rules: 
      - alert: SLOBudgetFastBurn 
        # ejemplo: usa nuestras m√©tricas del servicio si prefieres 
alertar fuera del gate 
        expr: slo_burn_rate_fast > 14.4 and slo_burn_rate_slow > 6 
        for: 10m 
        labels: { severity: warning } 
        annotations: 
          summary: "Fast+Slow burn altos ({{ $labels.slo }})" 
          description: "Revisar incidentes recientes y considerar 
freeze." 
      - alert: SLOBudgetDepleted 
        expr: slo_frozen == 1 
        for: 1m 
        labels: { severity: critical } 
        annotations: 
          summary: "Freeze activo por SLO ({{ $labels.slo }})" 
          description: "Deploys bloqueados hasta recuperaci√≥n." 
 
 
 
 
 README / Operaci√≥n 
Ruta completa: services/slo-budget/README.md 
# SLO & Error Budgets (GNEW N146) 
 
Servicio que calcula SLI/SLO desde Prometheus, vigila burn rates y 
aplica **FREEZE** de despliegues. 
 
## Endpoints - `POST /admin/slo` ‚Äî alta/edici√≥n de SLO (ver slo-catalog.yaml) - `GET  /slos` ‚Äî listado - `GET  /slos/:key` ‚Äî detalle - `POST /eval/:key` ‚Äî eval on-demand (tambi√©n hay scheduler interno) - `GET  /gate/:key` ‚Äî **gate** CI/CD. 200 OK = permitir; 423 Locked = 
**freeze** - `GET  /metrics` ‚Äî m√©tricas Prometheus (`slo_budget_remaining`, 
`slo_burn_rate_fast`, `slo_frozen`) 
 
## Ejemplo SLO de disponibilidad (99.9%/30d) 
```json 
{ 
  "key": "ai-api-availability", 
  "service": "ai-coordinator", 
  "env": "staging", 
  "target": 0.999, 
  "windowDays": 30, 
"goodExpr": 
"sum(increase(http_server_request_duration_seconds_count{job=\"ai-coor
 dinator\",status!~\"5..\"}[$window]))", 
"totalExpr": 
"sum(increase(http_server_request_duration_seconds_count{job=\"ai-coor
 dinator\"}[$window]))", 
"minRemaining": 0.2, 
"fastWin": "1h", "slowWin": "6h", "fastBurn": 14.4, "slowBurn": 6 
} 
Notas 
‚óè Las expresiones deben incluir $window (ej. 30d, 6h), el servicio las sustituye. 
‚óè Freeze se levanta autom√°ticamente cuando el presupuesto vuelve a estado saludable 
(decision OK). 
‚óè Integra con Slack/Webhooks al entrar/salir de freeze. --- 
## 
‚úÖ
 Cobertura del **DoD** - **Gesti√≥n activa de error budget**: c√°lculo cont√≠nuo de **SLI**, 
**budget remaining** y **burn rates** multi‚Äëventana; snapshots 
persistidos. - **Gates ‚Äúfreeze deploys‚Äù**: endpoint `/gate/:key` + **GitHub 
Actions** y **ArgoCD PreSync** bloquean despliegues al exceder el 
presupuesto. - **Roles SRE/Producto**: SRE configura SLOs/umbrales; Producto 
prioriza *feature freeze* y decisiones de mitigaci√≥n con evidencias 
(snapshots). - **Reversibilidad autom√°tica**: **unfreeze** cuando los indicadores 
se recuperan (sin intervenci√≥n manual). 
¬øQuieres que te incluya un **script de importaci√≥n** que lea 
`slo-catalog.yaml` y haga `POST /admin/slo` por cada entrada, y un 
**dashboard Grafana (JSON)** para budget, burn y freeze por servicio? 
 
T√∫ dijiste: 
continua programando gnew N147 15.7 Release Trains (Prompt 147) Objetivo: Cadencia fija 
con criterios de salida. Roles: Release Eng, QA, Producto. DoD: checklist cumplido; notas de 
versi√≥n. 
ChatGPT Plus 
Pens√≥ durante 1m 32s 
Aqu√≠ tienes el programa a nivel de detalle y entrega para GNEW N147 ‚Äî 15.7 Release 
Trains (Cadencia fija con criterios de salida). Incluye un servicio release-trains 
(Node/TypeScript + Prisma/PostgreSQL), orquestaci√≥n CI (GitHub Actions), checklist de 
salida, generaci√≥n autom√°tica de notas de versi√≥n desde conventional commits y gates 
contra SLOs (N146) para freeze cuando corresponda. 
 
 
 
 Servicio: services/release-trains 
Ruta completa: services/release-trains/package.json 
{ 
  "name": "@services/release-trains", 
  "version": "0.1.0", 
  "private": true, 
  "type": "module", 
  "main": "dist/index.js", 
  "scripts": { 
    "dev": "tsx watch src/index.ts", 
    "build": "tsc -p tsconfig.json && tsc-alias", 
    "start": "node dist/index.js", 
    "prisma:generate": "prisma generate", 
    "prisma:migrate": "prisma migrate deploy", 
    "prisma:dev": "prisma migrate dev --name init-release-trains" 
  }, 
  "dependencies": { 
    "@prisma/client": "^5.18.0", 
    "axios": "^1.7.7", 
    "cron-parser": "^5.0.4", 
    "date-fns": "^3.6.0", 
    "dotenv": "^16.4.5", 
    "express": "^4.19.2", 
    "morgan": "^1.10.0", 
    "prom-client": "^15.1.3", 
    "prisma": "^5.18.0", 
    "zod": "^3.23.8" 
  }, 
  "devDependencies": { 
    "@repo/typescript-config": "workspace:*", 
    "@types/express": "^4.17.21", 
    "@types/node": "^22.5.4", 
    "tsc-alias": "^1.8.10", 
    "tsx": "^4.17.0", 
    "typescript": "^5.5.4" 
  } 
} 
 
Ruta completa: services/release-trains/tsconfig.json 
{ 
  "extends": "@repo/typescript-config/node.json", 
  "compilerOptions": { 
    "rootDir": "src", 
    "outDir": "dist", 
    "baseUrl": "./src", 
    "paths": { "@/*": ["*"] } 
  }, 
  "include": ["src/**/*"] 
} 
 
Ruta completa: services/release-trains/.env.example 
PORT=8090 
DATABASE_URL=postgresql://gnew:gnew@postgres:5432/gnew_release_trains?
 schema=public 
# Integraciones opcionales 
SLO_GATE_BASE=http://slo-budget.gnew.svc.cluster.local:8089/gate 
GITHUB_TOKEN= # para usar gh api opcionalmente desde el pod (o usa GH 
Action) 
REPO_REMOTE=origin 
DEFAULT_MAIN_BRANCH=main 
NOTES_OUTPUT_DIR=/tmp/release-notes 
# Scheduler 
POLL_INTERVAL_SEC=60 
 
 
 Prisma (modelo de datos) 
Ruta completa: services/release-trains/prisma/schema.prisma 
generator client { provider = "prisma-client-js" } 
datasource db { provider = "postgresql"; url = env("DATABASE_URL") } 
model Train { 
id          
key         
env         
String   @id @default(cuid()) 
String   @unique          
// "weekly-train" 
String   @default("staging") 
description String? 
// Calendar/cadencia 
cron        
String                    
tz          
// "0 9 * * MON" (UTC) 
String   @default("Europe/Amsterdam") 
branchPrefix String  @default("release") 
// Criterios/gates globales 
sloKeys     
String[] @default([])     
checklistId String? 
createdAt   DateTime @default(now()) 
updatedAt   DateTime @updatedAt 
runs        
TrainRun[] 
// SLO keys para gate (N146) 
checklist   ChecklistTemplate? @relation(fields: [checklistId], 
references: [id], onDelete: SetNull) 
} 
 
model TrainRun { 
  id         String   @id @default(cuid()) 
  trainId    String 
  code       String   // "2025.34" (a√±o.semana) o "2025-08-19" 
  status     RunStatus @default(PLANNED) // 
PLANNED|IN_PROGRESS|READY|RELEASED|ABORTED|FROZEN 
  plannedAt  DateTime 
  startedAt  DateTime? 
  frozenReason String? 
  checklistStatus String? // OK|PENDING|FAILED 
  version    String?  // "v1.12.0" 
  tagName    String? 
  notesPath  String? 
  notesUrl   String? 
  createdAt  DateTime @default(now()) 
 
  artifacts  Artifact[] 
  checklist  ChecklistItem[] 
  train      Train @relation(fields: [trainId], references: [id], 
onDelete: Cascade) 
} 
 
model Artifact { 
  id      String   @id @default(cuid()) 
  runId   String 
  type    String   // "commit" | "pr" | "image" | "migration" 
  ref     String   // sha/pr#/imagename 
  title   String? 
  data    Json? 
  run     TrainRun @relation(fields: [runId], references: [id], 
onDelete: Cascade) 
} 
 
model ChecklistTemplate { 
  id      String   @id @default(cuid()) 
  key     String   @unique 
  name    String 
  items   Json     // [{key,type,label,required,meta?}, ...] 
  createdAt DateTime @default(now()) 
} 
 
model ChecklistItem { 
  id      String   @id @default(cuid()) 
  runId   String 
  key     String 
  type    String   // boolean|http|slogate|text 
  label   String 
  required Boolean @default(true) 
  status  String   @default("PENDING") // PENDING|OK|FAILED 
  details String? 
  updatedAt DateTime @updatedAt 
  run     TrainRun @relation(fields: [runId], references: [id], 
onDelete: Cascade) 
 
  @@index([runId, key]) 
} 
 
enum RunStatus { PLANNED IN_PROGRESS READY RELEASED ABORTED FROZEN } 
 
 
 
 
 C√≥digo del servicio 
Ruta completa: services/release-trains/src/config.ts 
import 'dotenv/config'; 
 
export const cfg = { 
  port: Number(process.env.PORT ?? 8090), 
  sloGateBase: process.env.SLO_GATE_BASE || '', 
  pollIntervalSec: Number(process.env.POLL_INTERVAL_SEC ?? 60), 
  mainBranch: process.env.DEFAULT_MAIN_BRANCH || 'main', 
  repoRemote: process.env.REPO_REMOTE || 'origin', 
  notesDir: process.env.NOTES_OUTPUT_DIR || '/tmp/release-notes' 
}; 
Ruta completa: services/release-trains/src/db.ts 
import { PrismaClient } from '@prisma/client'; 
export const prisma = new PrismaClient(); 
Ruta completa: services/release-trains/src/metrics.ts 
import client from 'prom-client'; 
export const reg = new client.Registry(); 
client.collectDefaultMetrics({ register: reg }); 
export const counters = { 
runsCreated: new client.Counter({ name: 
'release_runs_created_total', help: 'Runs creados', labelNames: 
['train'] }), 
runsReleased: new client.Counter({ name: 
'release_runs_released_total', help: 'Runs liberados', labelNames: 
['train'] }), 
runsFrozen: new client.Counter({ name: 'release_runs_frozen_total', 
help: 'Runs congelados', labelNames: ['train'] }) 
}; 
Object.values(counters).forEach(m => reg.registerMetric(m)); 
export async function metricsText(){ return reg.metrics(); } 
Ruta completa: services/release-trains/src/types.ts 
export type ChecklistDef = { key: string; type: 
'boolean'|'http'|'slogate'|'text'; label: string; required?: boolean; 
meta?: any; }; 
export type NotesSection = { title: string; entries: string[] }; 
Ruta completa: services/release-trains/src/sloGate.ts 
import axios from 'axios'; 
import { cfg } from './config'; 
export async function checkSloGate(keys: string[]) { 
  if (!cfg.sloGateBase || !keys?.length) return { ok: true, failed: [] 
as string[] }; 
  const fails: string[] = []; 
  await Promise.all(keys.map(async (k) => { 
    try { 
      const url = `${cfg.sloGateBase}/${encodeURIComponent(k)}`; 
      const r = await axios.get(url, { timeout: 4000 }); 
      if (r.status !== 200) fails.push(k); 
    } catch { fails.push(k); } 
  })); 
  return { ok: fails.length === 0, failed: fails }; 
} 
 
Ruta completa: services/release-trains/src/git.ts 
import { exec as _exec } from 'node:child_process'; 
import { promisify } from 'node:util'; 
import { mkdirSync, writeFileSync } from 'node:fs'; 
import { join } from 'node:path'; 
import { cfg } from './config'; 
 
const exec = promisify(_exec); 
 
export async function latestTag(): Promise<string|null> { 
  try { 
    const { stdout } = await exec('git describe --tags --abbrev=0'); 
    return stdout.trim(); 
  } catch { return null; } 
} 
 
export async function commitsSince(tag: string|null) { 
  const range = tag ? `${tag}..HEAD` : ''; 
  const cmd = `git log ${range} --pretty=format:%H|%s`; 
  const { stdout } = await exec(cmd); 
  return stdout.split('\n').filter(Boolean).map(l => { 
    const [sha, subject] = l.split('|'); 
    return { sha, subject }; 
  }); 
} 
 
export function detectBumpType(subjects: string[]): 
'major'|'minor'|'patch'|'none' { 
  // Convencional: feat -> minor, fix -> patch, break -> major 
  let major = false, minor = false, patch = false; 
  for (const s of subjects) { 
    const sub = s.toLowerCase(); 
    if (sub.includes('breaking change') || sub.match(/!\)/)) major = 
true; 
    if (sub.startsWith('feat')) minor = true; 
    if (sub.startsWith('fix') || sub.startsWith('perf') || 
sub.startsWith('chore')) patch = true; 
  } 
  if (major) return 'major'; 
  if (minor) return 'minor'; 
  if (patch) return 'patch'; 
  return 'none'; 
} 
 
export function bumpSemver(current: string|null, bump: 
'major'|'minor'|'patch'|'none'): string { 
  const base = (current ?? 'v0.0.0').replace(/^v/,''); 
  const [ma, mi, pa] = base.split('.').map(n => parseInt(n || '0', 
10)); 
  let M = ma, m = mi, p = pa; 
  if (bump === 'major') { M += 1; m = 0; p = 0; } 
  else if (bump === 'minor') { m += 1; p = 0; } 
  else if (bump === 'patch') { p += 1; } 
  const next = `v${M}.${m}.${p}`; 
  return current ? next : 'v0.1.0'; 
} 
 
export function buildReleaseNotes(version: string, sections: 
{title:string; entries:string[]}[]) { 
  const lines = [`# ${version}`, '', `Fecha: ${new 
Date().toISOString()}`, '']; 
  for (const s of sections) { 
    lines.push(`## ${s.title}`, ''); 
    if (s.entries.length === 0) { lines.push('- (sin cambios)'); } 
    else for (const e of s.entries) lines.push(`- ${e}`); 
    lines.push(''); 
  } 
  mkdirSync(cfg.notesDir, { recursive: true }); 
  const path = join(cfg.notesDir, `${version}.md`); 
  writeFileSync(path, lines.join('\n'), 'utf-8'); 
  return path; 
} 
 
Ruta completa: services/release-trains/src/checklist.ts 
import axios from 'axios'; 
import { prisma } from './db'; 
import { ChecklistDef } from './types'; 
import { checkSloGate } from './sloGate'; 
 
export async function seedChecklist(templateKey: string, defs: 
ChecklistDef[]) { 
  const item = await prisma.checklistTemplate.upsert({ 
    where: { key: templateKey }, 
    update: { name: templateKey, items: defs as any }, 
    create: { key: templateKey, name: templateKey, items: defs as any 
} 
  }); 
  return item; 
} 
 
export async function instantiateChecklist(runId: string, templateKey: 
string) { 
  const tmpl = await prisma.checklistTemplate.findUnique({ where: { 
key: templateKey }}); 
  if (!tmpl) throw new Error('template_not_found'); 
  const defs = (tmpl.items as any[]) || []; 
  await prisma.checklistItem.createMany({ 
    data: defs.map(d => ({ 
      runId, key: d.key, type: d.type, label: d.label, required: 
d.required ?? true, status: 'PENDING', details: '' 
    })) 
  }); 
} 
 
export async function evalChecklist(runId: string, sloKeys: string[]) 
{ 
  const items = await prisma.checklistItem.findMany({ where: { runId 
}}); 
  const results: { id: string; ok: boolean; details?: string }[] = []; 
 
  // Primero, SLO gates globales si hay √≠tem slogate 
  const slogateItems = items.filter(i => i.type === 'slogate'); 
  if (slogateItems.length && sloKeys.length) { 
    const gate = await checkSloGate(sloKeys); 
    for (const it of slogateItems) { 
      results.push({ id: it.id, ok: gate.ok, details: gate.ok ? 'ok' : 
`failed: ${gate.failed.join(',')}` }); 
    } 
  } 
 
  // Otros tipos 
  for (const it of items.filter(i => i.type !== 'slogate')) { 
    if (it.type === 'boolean') { 
      // el valor se marca por API externa (/checklist/:id/ok) 
      results.push({ id: it.id, ok: it.status === 'OK', details: 
it.details ?? '' }); 
    } else if (it.type === 'http') { 
      const url = it.details || ''; // guardamos URL en details al 
crear 
      try { 
        const r = await axios.get(url, { timeout: 4000 }); 
        results.push({ id: it.id, ok: r.status >= 200 && r.status < 
300, details: `HTTP ${r.status}` }); 
      } catch (e:any) { 
        results.push({ id: it.id, ok: false, details: e?.message || 
'http_error' }); 
      } 
    } else if (it.type === 'text') { 
      results.push({ id: it.id, ok: !!it.details?.trim(), details: 
it.details || '' }); 
    } 
  } 
 
  // persistir 
  for (const r of results) { 
    await prisma.checklistItem.update({ where: { id: r.id }, data: { 
status: r.ok ? 'OK' : 'FAILED', details: r.details ?? '' }}); 
  } 
 
  const finalItems = await prisma.checklistItem.findMany({ where: { 
runId }}); 
  const required = finalItems.filter(i => i.required); 
  const okAll = required.every(i => i.status === 'OK'); 
  const failedSome = required.some(i => i.status === 'FAILED'); 
 
  return { okAll, failedSome, items: finalItems }; 
} 
 
Ruta completa: services/release-trains/src/trains.ts 
import cronParser from 'cron-parser'; 
import { formatInTimeZone } from 'date-fns-tz'; 
import { addMinutes } from 'date-fns'; 
import { prisma } from './db'; 
import { counters } from './metrics'; 
 
export async function ensurePlannedRuns() { 
  const trains = await prisma.train.findMany(); 
  for (const t of trains) { 
    const interval = cronParser.parseExpression(t.cron, { tz: t.tz || 
'UTC' }); 
    const next = interval.next().toDate(); 
    const code = formatInTimeZone(next, t.tz || 'UTC', 'yyyy.II'); // 
semana ISO como release train por defecto 
    // ¬øya existe un run PLANNED para ese code? 
    const exists = await prisma.trainRun.findFirst({ where: { trainId: 
t.id, code }}); 
    if (!exists) { 
      await prisma.trainRun.create({ 
        data: { 
          trainId: t.id, 
          code, 
          status: 'PLANNED', 
          plannedAt: addMinutes(next, 0) 
        } 
      }); 
      counters.runsCreated.labels(t.key).inc(); 
    } 
  } 
} 
 
Ruta completa: services/release-trains/src/notes.ts 
import { commitsSince, detectBumpType, latestTag, bumpSemver, 
buildReleaseNotes } from './git'; 
 
export async function generateNotesForRun(): Promise<{ version: 
string; path: string; subjects: string[] }> { 
  const tag = await latestTag(); 
  const commits = await commitsSince(tag); 
  const subjects = commits.map(c => c.subject); 
  const bump = detectBumpType(subjects); 
  const next = bumpSemver(tag, bump); 
  // Secciones por tipo 
  const feat = subjects.filter(s => 
s.toLowerCase().startsWith('feat')); 
  const fix  = subjects.filter(s => s.toLowerCase().startsWith('fix') 
|| s.toLowerCase().startsWith('perf')); 
  const chore= subjects.filter(s => 
s.toLowerCase().startsWith('chore')); 
  const other= subjects.filter(s => ![...feat, ...fix, 
...chore].includes(s)); 
  const path = buildReleaseNotes(next, [ 
    { title: '
 üöÄ
 Features', entries: feat }, 
    { title: '
 üêõ
 Fixes / Perf', entries: fix }, 
    { title: '
 üßπ
 Chores', entries: chore }, 
    { title: 'Otros', entries: other } 
  ]); 
  return { version: next, path, subjects }; 
} 
 
Ruta completa: services/release-trains/src/controllers.ts 
import { prisma } from './db'; 
import { z } from 'zod'; 
import { generateNotesForRun } from './notes'; 
import { evalChecklist, instantiateChecklist } from './checklist'; 
import { counters } from './metrics'; 
 
export async function upsertTrain(input: any) { 
  const S = z.object({ 
    key: z.string(), env: z.string().default('staging'), 
    description: z.string().optional(), 
    cron: z.string(), 
    tz: z.string().default('Europe/Amsterdam'), 
    branchPrefix: z.string().default('release'), 
    sloKeys: z.array(z.string()).default([]), 
    checklistKey: z.string().optional() 
  }).parse(input); 
 
  const checklist = S.checklistKey 
    ? await prisma.checklistTemplate.findUnique({ where: { key: 
S.checklistKey }}) 
    : null; 
 
  const t = await prisma.train.upsert({ 
    where: { key: S.key }, 
    update: { 
      env: S.env, description: S.description, 
      cron: S.cron, tz: S.tz, branchPrefix: S.branchPrefix, sloKeys: 
S.sloKeys, 
      checklistId: checklist?.id 
    }, 
    create: { 
      key: S.key, env: S.env, description: S.description || null, 
      cron: S.cron, tz: S.tz, branchPrefix: S.branchPrefix, sloKeys: 
S.sloKeys, checklistId: checklist?.id 
    } 
  }); 
  return t; 
} 
 
export async function startRun(runId: string) { 
  const run = await prisma.trainRun.update({ where: { id: runId }, 
data: { status: 'IN_PROGRESS', startedAt: new Date() }, include: { 
train: true }}); 
  if (run.train.checklistId) await instantiateChecklist(run.id, (await 
prisma.checklistTemplate.findUnique({ where: { id: 
run.train.checklistId }}))!.key); 
  return run; 
} 
 
export async function evaluateExitCriteria(runId: string) { 
  const run = await prisma.trainRun.findUnique({ where: { id: runId }, 
include: { train: true }}); 
  if (!run) throw new Error('run_not_found'); 
  const res = await evalChecklist(runId, run.train.sloKeys); 
  const status = res.okAll ? 'READY' : (res.failedSome ? 'FROZEN' : 
'IN_PROGRESS'); 
  const frozenReason = res.failedSome ? 'checklist_failed' : null; 
  await prisma.trainRun.update({ where: { id: runId }, data: { status, 
checklistStatus: res.okAll ? 'OK' : (res.failedSome ? 'FAILED' : 
'PENDING'), frozenReason }}); 
  return { status, checklist: res.items }; 
} 
 
export async function produceReleaseNotes(runId: string) { 
const { version, path } = await generateNotesForRun(); 
await prisma.trainRun.update({ where: { id: runId }, data: { 
version, notesPath: path }}); 
return { version, path }; 
} 
export async function markReleased(runId: string, tagName: string, 
notesUrl?: string) { 
await prisma.trainRun.update({ where: { id: runId }, data: { status: 
'RELEASED', tagName, notesUrl: notesUrl ?? null }}); 
const run = await prisma.trainRun.findUnique({ where: { id: runId }, 
include: { train: true }}); 
counters.runsReleased.labels(run!.trainId); 
return run; 
} 
export async function markFrozen(runId: string, reason: string) { 
await prisma.trainRun.update({ where: { id: runId }, data: { status: 
'FROZEN', frozenReason: reason }}); 
counters.runsFrozen.labels((await prisma.trainRun.findUnique({ 
where: { id: runId }}))!.trainId); 
} 
Ruta completa: services/release-trains/src/app.ts 
import express from 'express'; 
import morgan from 'morgan'; 
import { metricsText } from './metrics'; 
import * as ctrl from './controllers'; 
import { ensurePlannedRuns } from './trains'; 
import { prisma } from './db'; 
import { cfg } from './config'; 
import { z } from 'zod'; 
export function createApp() { 
const app = express(); 
app.use(express.json()); 
app.use(morgan('tiny')); 
 
  app.get('/healthz', (_req,res)=>res.json({status:'ok'})); 
  app.get('/metrics', async (_req,res)=>{ 
res.set('Content-Type','text/plain'); res.send(await metricsText()); 
}); 
 
  // Admin 
  app.post('/admin/train', async (req,res,next)=>{ try { 
res.json(await ctrl.upsertTrain(req.body)); } catch(e){ next(e); }}); 
  app.get('/runs/:id', async (req,res)=> res.json(await 
prisma.trainRun.findUnique({ where: { id: req.params.id }, include: { 
checklist: true, train: true }}))); 
  app.get('/trains', async (_req,res)=> res.json(await 
prisma.train.findMany({ include: { runs: true }}))); 
 
  // Lifecycle 
  app.post('/runs/:id/start', async (req,res,next)=>{ try { 
res.json(await ctrl.startRun(req.params.id)); } catch(e){ next(e); 
}}); 
  app.post('/runs/:id/evaluate', async (req,res,next)=>{ try { 
res.json(await ctrl.evaluateExitCriteria(req.params.id)); } catch(e){ 
next(e); }}); 
  app.post('/runs/:id/notes', async (req,res,next)=>{ try { 
res.json(await ctrl.produceReleaseNotes(req.params.id)); } catch(e){ 
next(e); }}); 
  app.post('/runs/:id/released', async (req,res,next)=>{ try { 
    const S = z.object({ tagName: z.string(), notesUrl: 
z.string().optional() }).parse(req.body); 
    res.json(await ctrl.markReleased(req.params.id, S.tagName, 
S.notesUrl)); 
  } catch(e){ next(e); }}); 
  app.post('/runs/:id/frozen', async (req,res,next)=>{ try { 
    const S = z.object({ reason: z.string() }).parse(req.body); 
    res.json(await ctrl.markFrozen(req.params.id, S.reason)); 
  } catch(e){ next(e); }}); 
 
  // Checklist manual OK/fail + detalles 
  app.post('/checklist/:id/status', async (req,res,next)=>{ try { 
const S = z.object({ status: z.enum(['OK','FAILED','PENDING']), 
details: z.string().optional() }).parse(req.body); 
const r = await prisma.checklistItem.update({ where: { id: 
req.params.id }, data: { status: S.status, details: S.details ?? '' 
}}); 
res.json(r); 
} catch(e){ next(e); }}); 
// Scheduler: planifica pr√≥ximos runs 
setInterval(() => { ensurePlannedRuns().catch(()=>{}); }, 
cfg.pollIntervalSec * 1000); 
// Error 
app.use((err:any,_req:any,res:any,_next:any)=>{ console.error(err); 
res.status(400).json({ error: err.message || 'bad_request' }); }); 
return app; 
} 
Ruta completa: services/release-trains/src/index.ts 
import { createApp } from './app'; 
import { cfg } from './config'; 
createApp().listen(cfg.port, ()=>console.log(`[release-trains] 
:${cfg.port}`)); 
Ruta completa: services/release-trains/Dockerfile 
FROM node:20-alpine AS deps 
WORKDIR /app 
COPY package.json package-lock.json* pnpm-lock.yaml* yarn.lock* 
.npmrc* ./ 
RUN --mount=type=cache,target=/root/.npm npm ci || npm i 
FROM node:20-alpine AS build 
WORKDIR /app 
COPY --from=deps /app/node_modules ./node_modules 
COPY . . 
RUN npm run prisma:generate 
RUN npm run build && npx tsc-alias 
FROM node:20-alpine 
WORKDIR /app 
ENV NODE_ENV=production 
RUN apk add --no-cache git 
COPY --from=build /app/node_modules ./node_modules 
COPY --from=build /app/dist ./dist 
COPY --from=build /app/prisma ./prisma 
COPY --from=build /app/package.json . 
EXPOSE 8090 
HEALTHCHECK --interval=30s --timeout=3s CMD wget -qO- 
http://localhost:8090/healthz || exit 1 
CMD ["node","dist/index.js"] 
 
 
 Checklist de salida (plantilla) 
Ruta completa: tools/release-trains/checklists/weekly.json 
[ 
{ "key": "qa-signoff",     
"type": "boolean", "label": "QA sign-off 
(regresi√≥n y humo)", "required": true }, 
{ "key": "slo-gate",       
"type": "slogate", "label": "SLO gates OK 
(N146)",            
"required": true }, 
{ "key": "docs-updated",   "type": "boolean", "label": "Docs y 
migraciones actualizadas", "required": true }, 
{ "key": "links-notes",    
"type": "text",    
notas de versi√≥n",      
"required": true }, 
{ "key": "api-health",     
"type": "http",    
API estable",           
"label": "URL draft 
"label": "Health de 
"required": true, "meta": { "url": 
"http://gateway:8000/healthz" } } 
] 
Carga la plantilla (una vez) con POST /admin/train usando checklistKey 
tras seed: 
Ruta completa: 
services/release-trains/scripts/seed-checklist.ts 
import { seedChecklist } from '../src/checklist'; 
import { readFileSync } from 'node:fs'; 
import { resolve } from 'node:path'; 
(async ()=>{ 
  const defs = JSON.parse(readFileSync(resolve(process.cwd(), 
'tools/release-trains/checklists/weekly.json'),'utf-8')); 
  await seedChecklist('weekly', defs); 
  // Opcional: setea URL en item http 
  process.exit(0); 
})(); 
 
 
 
 
 CI: Tren semanal + publicaci√≥n 
