```yaml 
name: DR Verify (Quarterly) 
on: 
  schedule: 
    - cron: "0 3 1 */3 *" 
  workflow_dispatch: {} 
jobs: 
  verify: 
    runs-on: ubuntu-latest 
    permissions: 
      id-token: write 
      contents: read 
    steps: 
      - uses: actions/checkout@v4 
      - name: Setup kubectl & helm 
        uses: azure/setup-kubectl@v4 
      - name: Auth to cluster (OIDC) 
        run: | 
          # Reemplazar por autenticación real (EKS/GKE/AKS) 
          echo "KUBECONFIG" | sed 's/^/TODO/' 
      - name: Trigger Job 
        run: bash scripts/dr/trigger-verify.sh 
 
Ruta completa: infra/compose/backup/backup.sh 
#!/usr/bin/env bash 
# Backup local para entorno compose (desarrollo) 
set -euo pipefail 
ROOT="$(cd "$(dirname "$0")"/../.. && pwd)" 
OUT="$ROOT/infra/compose/data/backups" 
mkdir -p "$OUT" 
date=$(date -u +%Y%m%dT%H%M%SZ) 
docker exec -e PGPASSWORD=postgres postgres pg_dump -U postgres 
gateway | gzip -9 > "$OUT/gateway-${date}.sql.gz" 
sha256sum "$OUT/gateway-${date}.sql.gz" > 
"$OUT/gateway-${date}.sha256" 
echo "Backup local en $OUT" 
Cómo encaja con GNEW (entregables y 
DoD) 
● Entregables 
○ Plan DR multi-región: Terraform (infra/terraform/backup/*) crea bucket 
cifrado con KMS, versión + replicación inter-región (primaria→secundaria). 
○ Snapshots cifrados: Velero configurado 
(infra/kubernetes/backup/velero-values.yaml) usa SSE-KMS y 
snapshots de PV. 
○ Pruebas de restauración: CronJob trimestral 
(cronjob-restore-verify.yaml) restaura en un namespace efímero y hace 
healthchecks end-to-end. 
○ RPO/RTO: definidos en docs/slo-dr.md; alertas Prometheus en 
infra/monitoring/prometheus/rules/backup-alerts.yaml. 
○ Runbook: docs/dr-runbook.md con pasos manuales y roles. 
● Definición de Hecho (DoD) 
○ terraform plan/apply sin drift para los buckets/KMS/replicación. 
○ Despliegue idempotente de Velero y CronJobs (helm/manifest). 
○ Métricas expuestas y alertas activas: 
■ gnew_backup_last_success_timestamp_seconds actualizado 
cada 30 min. 
■ Verificación DR trimestral con gnew_dr_last_restore_*. 
○ Restauraciones trimestrales exitosas: el CronJob crea restore, valida health y 
publica gnew_dr_last_restore_success 1. Cualquier fallo gatilla 
DRRestoreFailed. 
○ Auditoría: todos los objetos en S3 con SSE-KMS y versioning; logs de 
replicación habilitados vía IAM role en el módulo de replication. 
Para ejecutar: 
1. terraform -chdir=infra/terraform/backup init && 
terraform -chdir=infra/terraform/backup apply -var="env=prod" 
2. bash scripts/dr/velero-install.sh y aplicar manifests: kubectl 
apply -f infra/kubernetes/backup/ 
3. Importar reglas en Prometheus o helm chart de monitoring. 
4. Disparar prueba manual: bash scripts/dr/trigger-verify.sh. 
Tú dijiste: 
programa para GNEW a nivel de detalle N97 10.7 Gestión de costes (Prompt 97) Objetivo: 
Visibilidad y optimización de gasto. Roles: FinOps, SRE. Stack: Cost explorer, etiquetas, 
presupuestos y alertas. Entregables: Reportes mensuales y recomendaciones. DoD: Ahorro ≥ 
X% sin perder SLOs. 
ChatGPT Plus 
Pensó durante 1m 15s 
Ruta completa: infra/finops/README.md 
# GNEW · N97 (10.7) Gestión de costes 
**Objetivo:** visibilidad y optimización del gasto **multi-cloud** sin 
degradar SLOs.   
**Roles:** FinOps, SRE.   
**Stack:** AWS Budgets/Cost Explorer + CUR (Athena), GCP Budgets + 
BigQuery billing export, Azure Cost Management, OpenCost (K8s), 
etiquetas normalizadas, reportes mensuales y recomendaciones 
automáticas. 
## Entregables - **IaC** para presupuestos, alertas y export de costes 
(AWS/GCP/Azure). - **Etiquetado/labels** obligatorio (políticas y validaciones). - **OpenCost** desplegado en Kubernetes (coste por 
namespace/servicio). - **Reporte mensual** (Markdown + Slack) con KPIs, desglose, 
**recomendaciones** y **ahorro proyectado**. - **Guardas de SLO**: no recomendar ahorros que erosionen el error 
budget. - **DoD**: Ahorro ≥ X% (configurable) sin perder SLOs; auditoría de 
recomendaciones aplicadas. 
## RPO/RTO FinOps - Actualización diaria de datos de costes (CUR/BQ export). - Reporte **mensual** (día 1) y **semanal** (resumen corto). 
IaC – AWS (Budgets, CUR, Athena, Tag 
Policies) 
Ruta completa: infra/finops/aws/providers.tf 
terraform { 
required_providers { 
aws = { source = "hashicorp/aws", version = "~> 5.60" } 
} 
required_version = ">= 1.7.0" 
} 
# Cuenta/region primaria 
provider "aws" { 
region = var.region 
} 
# CUR solo en us-east-1 
provider "aws" { 
alias  = "cur" 
region = "us-east-1" 
} 
Ruta completa: infra/finops/aws/variables.tf 
variable "region"           
variable "env"              
{ type = string  default = "eu-west-1" } 
{ type = string  default = "prod" } 
variable "billing_emails"   { type = list(string) default = [] } 
variable "slack_topic_arn"  { type = string  default = null } # 
SNS->Slack (Chatbot/Lambda) 
variable "monthly_budget_usd" { type = number default = 5000 } 
variable "tags_required" { 
type = list(string) 
default = ["project","service","env","owner","cost_center"] 
} 
Ruta completa: infra/finops/aws/budgets.tf 
resource "aws_sns_topic" "finops" { name = "gnew-finops-${var.env}" } 
resource "aws_sns_topic_policy" "finops" { 
arn = aws_sns_topic.finops.arn 
policy = data.aws_iam_policy_document.finops_sns.json 
} 
data "aws_iam_policy_document" "finops_sns" { 
  statement { 
    effect = "Allow" 
    principals { type = "Service", identifiers = 
["budgets.amazonaws.com"] } 
    actions   = ["SNS:Publish"] 
    resources = [aws_sns_topic.finops.arn] 
  } 
} 
 
# Presupuesto mensual por cuenta (gasto total) 
resource "aws_budgets_budget" "monthly_total" { 
  name              = "GNEW-${var.env}-Monthly" 
  budget_type       = "COST" 
  limit_amount      = format("%.2f", var.monthly_budget_usd) 
  limit_unit        = "USD" 
  time_unit         = "MONTHLY" 
 
  notification { 
    comparison_operator        = "GREATER_THAN" 
    threshold                  = 80 
    threshold_type             = "PERCENTAGE" 
    notification_type          = "ACTUAL" 
    subscriber_email_addresses = var.billing_emails 
    subscriber_sns_topic_arns  = compact([aws_sns_topic.finops.arn, 
var.slack_topic_arn]) 
  } 
  notification { 
    comparison_operator       = "GREATER_THAN" 
    threshold                 = 100 
    threshold_type            = "PERCENTAGE" 
    notification_type         = "FORECASTED" 
    subscriber_sns_topic_arns = compact([aws_sns_topic.finops.arn, 
var.slack_topic_arn]) 
  } 
} 
 
# Presupuestos por etiqueta service (ej.: gateway) 
resource "aws_budgets_budget" "per_service" { 
  for_each    = toset(["gateway","wallet","defi","ai-coordinator"]) 
  name        = "GNEW-${var.env}-${each.key}-Monthly" 
  budget_type = "COST" 
  limit_amount = "1000" 
  limit_unit   = "USD" 
  time_unit    = "MONTHLY" 
  cost_filters = { 
    "TagKeyValue" = ["user:service$${each.key}"] 
  } 
  notification { 
    comparison_operator       = "GREATER_THAN" 
    threshold                 = 100 
    threshold_type            = "PERCENTAGE" 
    notification_type         = "FORECASTED" 
    subscriber_sns_topic_arns = [aws_sns_topic.finops.arn] 
  } 
} 
 
Ruta completa: infra/finops/aws/cur.tf 
# S3 donde aterriza el CUR (usa us-east-1) 
resource "aws_s3_bucket" "cur" { 
  provider = aws.cur 
  bucket   = "gnew-cur-${var.env}" 
} 
 
resource "aws_s3_bucket_policy" "cur" { 
  provider = aws.cur 
  bucket   = aws_s3_bucket.cur.id 
  policy   = data.aws_iam_policy_document.cur_write.json 
} 
 
data "aws_iam_policy_document" "cur_write" { 
  statement { 
    sid     = "BillingReportsWrite" 
    effect  = "Allow" 
    principals { type = "Service", identifiers = 
["billingreports.amazonaws.com"] } 
    actions = ["s3:GetBucketAcl","s3:GetBucketPolicy","s3:PutObject"] 
    resources = [ 
      aws_s3_bucket.cur.arn, 
      "${aws_s3_bucket.cur.arn}/*" 
    ] 
  } 
} 
 
resource "aws_cur_report_definition" "gnew" { 
  provider                 = aws.cur 
  report_name              = "gnew-${var.env}-cur" 
  time_unit                = "DAILY" 
  format                   = "Parquet" 
  compression              = "Parquet" 
  additional_schema_elements = ["RESOURCES"] 
  s3_bucket                = aws_s3_bucket.cur.bucket 
  s3_region                = "us-east-1" 
  s3_prefix                = "cur" 
  refresh_closed_reports   = true 
  report_versioning        = "OVERWRITE_REPORT" 
} 
 
# Glue + Athena para consultar CUR 
resource "aws_glue_database" "cur" { 
  name = "gnew_cur_${var.env}" 
} 
 
resource "aws_glue_crawler" "cur" { 
  name          = "gnew-cur-${var.env}" 
  role          = aws_iam_role.crawler.arn 
  database_name = aws_glue_database.cur.name 
  s3_target { path = "s3://${aws_s3_bucket.cur.bucket}/cur/" } 
  schedule = "cron(0 3 * * ? *)" 
} 
 
resource "aws_iam_role" "crawler" { 
  name = "gnew-cur-crawler" 
  assume_role_policy = jsonencode({ 
    Version="2012-10-17", 
    
Statement=[{Effect="Allow",Principal={Service="glue.amazonaws.com"},Ac
 tion="sts:AssumeRole"}] 
  }) 
} 
 
resource "aws_iam_role_policy" "crawler" { 
  name = "gnew-cur-crawler" 
  role = aws_iam_role.crawler.id 
  policy = jsonencode({ 
    Version="2012-10-17", 
    Statement=[ 
      
{Effect="Allow",Action=["s3:*"],Resource=[aws_s3_bucket.cur.arn,"${aws
 _s3_bucket.cur.arn}/*"]}, 
      
{Effect="Allow",Action=["logs:*","glue:*","athena:*"],Resource="*"} 
    ] 
  }) 
} 
 
resource "aws_athena_workgroup" "finops" { 
  name = "gnew-finops" 
  configuration { 
    enforce_workgroup_configuration = false 
    result_configuration { output_location = 
"s3://${aws_s3_bucket.cur.bucket}/athena-results/" } 
  } 
} 
 
Ruta completa: infra/finops/aws/tags-policy.tf 
# Opcional si se usa AWS Organizations (en raíz de la org) 
# Enforce Tag Policy: project, service, env, owner, cost_center 
resource "aws_organizations_policy" "tag_policy" { 
  name        = "gnew-required-tags" 
  description = "Require standard tags" 
  type        = "TAG_POLICY" 
  content     = jsonencode({ 
    tags = { 
      project     = { tag_key = { "@@assign": "project" }, tag_value = 
{ "@@regex": "gnew" } } 
      service     = { tag_key = { "@@assign": "service" }, tag_value = 
{ "@@regex": "^[a-z0-9-]+$" } } 
      env         = { tag_key = { "@@assign": "env" }, tag_value = { 
"@@enum": ["dev","staging","prod"] } } 
      owner       = { tag_key = { "@@assign": "owner" }, tag_value = { 
"@@regex": ".*" } } 
      cost_center = { tag_key = { "@@assign": "cost_center" }, 
tag_value = { "@@regex": "^[A-Z]{3}[0-9]{3}$" } } 
    } 
  }) 
} 
 
# Adjunta a la OU/Account deseada (reemplazar ID) 
# resource "aws_organizations_policy_attachment" "attach" { 
#   policy_id = aws_organizations_policy.tag_policy.id 
#   target_id = "ou-xxxx-xxxxxxxx" 
# } 
 
 
IaC – GCP (Budgets + BigQuery export) 
Ruta completa: infra/finops/gcp/main.tf 
terraform { 
  required_providers { 
    google = { source = "hashicorp/google", version = "~> 6.10" } 
  } 
} 
provider "google" { 
  project = var.project 
} 
 
variable "project"         { type = string } 
variable "billing_account" { type = string } 
variable "budget_amount"   { type = number default = 3000 } 
variable "alert_pubsub"    { type = string default = null } # topic 
name 
 
# Budget mensual a nivel de billing account 
resource "google_billing_budget" "monthly" { 
  billing_account = var.billing_account 
  display_name    = "GNEW Monthly" 
  amount { specified_amount { currency_code = "USD" units = 
tostring(var.budget_amount) } } 
  threshold_rules { 
    threshold_percent = 0.8 
  } 
  threshold_rules { 
    threshold_percent = 1.0 
    spend_basis       = "FORECASTED_SPEND" 
  } 
  all_updates_rule { 
    pubsub_topic = var.alert_pubsub != null ? 
"projects/${var.project}/topics/${var.alert_pubsub}" : null 
    schema_version = "1.0" 
  } 
} 
 
# Dataset para export de facturación (activar export desde consola o 
API) 
resource "google_bigquery_dataset" "billing" { 
  dataset_id = "gnew_billing" 
  location   = "EU" 
} 
 
 
IaC – Azure (Budgets + Tag Policy) 
Ruta completa: infra/finops/azure/main.tf 
terraform { 
  required_providers { 
    azurerm = { source = "hashicorp/azurerm", version = "~> 4.10" } 
  } 
} 
provider "azurerm" { features {} } 
 
variable "budget_amount" { type = number default = 2500 } 
 
resource "azurerm_consumption_budget_subscription" "monthly" { 
  name            = "gnew-monthly" 
  amount          = var.budget_amount 
  time_grain      = "Monthly" 
  subscription_id = data.azurerm_client_config.current.subscription_id 
 
  time_period { 
    start_date = formatdate("YYYY-MM-01'T'00:00:00Z", timestamp()) 
    end_date   = formatdate("YYYY-MM-01'T'00:00:00Z", 
timeadd(timestamp(), "8760h")) # +1y 
  } 
 
  notification { 
    enabled        = true 
    threshold      = 80.0 
    operator       = "EqualTo" 
    contact_emails = ["finops@gnew.example"] 
  } 
  notification { 
    enabled        = true 
    threshold      = 100.0 
    operator       = "GreaterThan" 
    contact_emails = ["finops@gnew.example"] 
  } 
} 
 
data "azurerm_client_config" "current" {} 
 
# Política: requerir tags 
resource "azurerm_policy_definition" "require_tags" { 
  name         = "gnew-require-tags" 
  policy_type  = "Custom" 
  mode         = "Indexed" 
  display_name = "Require standard tags" 
  policy_rule = jsonencode({ 
    if = { allOf = [ 
      { field = "type", notContains = 
"/providers/Microsoft.Authorization/policy" }, 
      for t in ["project","service","env","owner","cost_center"] : { 
field = "[concat('tags[', '${t}', ']')]", equals = "" } 
    ] } 
    then = { effect = "deny" } 
  }) 
} 
 
resource "azurerm_policy_assignment" "assign" { 
  name                 = "gnew-require-tags" 
  policy_definition_id = azurerm_policy_definition.require_tags.id 
  scope                = 
data.azurerm_client_config.current.subscription_id 
} 
 
 
Kubernetes – OpenCost (coste por 
namespace/servicio) 
Ruta completa: infra/iac/terraform/k8s/opencost.tf 
terraform { 
  required_providers { 
    helm = { source = "hashicorp/helm", version = "~> 2.15" } 
    kubernetes = { source = "hashicorp/kubernetes", version = "~> 
2.31" } 
  } 
} 
variable "kubeconfig_path" { type = string } 
provider "kubernetes" { config_path = var.kubeconfig_path } 
provider "helm" { kubernetes { config_path = var.kubeconfig_path } } 
 
resource "helm_release" "opencost" { 
  name             = "opencost" 
  repository       = "https://opencost.github.io/opencost-helm-chart" 
  chart            = "opencost" 
  version          = "1.35.0" 
  namespace        = "opencost" 
  create_namespace = true 
  values = [yamlencode({ 
    opencost = { 
      exporter = { defaultClusterId = "gnew-cluster" } 
      ui = { enabled = false } 
    } 
    prometheus = { internal = { enabled = false } } # usamos el stack 
existente 
    serviceMonitor = { enabled = true } 
  })] 
} 
 
Requiere que todos los Deployments lleven etiquetas estándar (project=gnew, 
service, env, owner, cost_center). Añade a tus charts/templates: 
 metadata.labels: { project: gnew, service: <svc>, env: <env>, 
owner: <team>, cost_center: <cc> }. 
 
Políticas OPA/Conftest para etiquetas 
(Terraform) 
Ruta completa: infra/iac/policies/finops-tags.rego 
package terraform.finops 
 
required := {"project","service","env","owner","cost_center"} 
deny[msg] { 
input.resource.type != "helm_release" 
not input.resource.values.tags 
msg := sprintf("Recurso %s sin tags.", [input.resource.address]) 
} 
deny[msg] { 
some k 
required[k] 
val := input.resource.values.tags[k] 
not val 
msg := sprintf("Falta tag '%s' en %s.", [k, input.resource.address]) 
} 
Servicio de Reporte mensual + 
recomendaciones 
Ruta completa: services/finops-report/requirements.txt 
boto3==1.34.131 
google-cloud-bigquery==3.25.0 
azure-identity==1.16.0 
azure-mgmt-consumption==9.0.0 
requests==2.32.3 
PyYAML==6.0.2 
Jinja2==3.1.4 
Ruta completa: services/finops-report/config.yaml 
savings_target_pct: 0.10   # X = 10% por defecto 
prometheus_url: http://prometheus.monitoring.svc:9090 
opencost_url: http://opencost.opencost.svc:9003 
slo: 
  # margen mínimo de error budget requerido para sugerir ahorro 
  min_error_budget_remaining_pct: 20 
services: 
  - name: gateway 
    slo_availability_target: 0.999 
  - name: wallet 
    slo_availability_target: 0.999 
  - name: defi 
    slo_availability_target: 0.995 
 
Ruta completa: services/finops-report/main.py 
import os, json, datetime, requests, yaml, math, pathlib 
from jinja2 import Template 
 
CONF = 
yaml.safe_load(open(os.getenv("FINOPS_CONF","services/finops-report/co
 nfig.yaml"))) 
PROM = CONF["prometheus_url"] 
OC   = CONF["opencost_url"] 
 
def q(expr): 
    r = requests.get(f"{PROM}/api/v1/query", params={"query":expr}, 
timeout=10) 
    r.raise_for_status() 
    d = r.json()["data"]["result"] 
    return float(d[0]["value"][1]) if d else float("nan") 
 
def slo_ok(service, target, window="30d"): 
    # disponibilidad aproximada: 1 - error_rate 
    err = 
f"sum(rate(http_requests_total{{service='{service}',status=~'5..'}}[{w
 indow}])) / 
sum(rate(http_requests_total{{service='{service}'}}[{window}]))" 
    error_rate = q(err) 
    if math.isnan(error_rate): return (True, 1.0, 1.0) 
    avail = 1.0 - error_rate 
    eb_rem = max(0.0, (avail - target) / (1 - target))  # fracción de 
error budget restante 
    return (eb_rem*100 >= 
CONF["slo"]["min_error_budget_remaining_pct"], avail, eb_rem) 
 
def opencost_ns(window="30d"): 
    url = f"{OC}/allocation/compute" 
    r = requests.get(url, 
params={"window":window,"aggregate":"namespace","accumulate":"false"}, 
timeout=10) 
    r.raise_for_status() 
    return r.json() # [{name, totalCost, cpuCost, ramCost, ...}] 
 
def recommend_rightsize(window="7d"): 
    # Heurística simple: si p95 de uso < 50% de request -> bajar 20% 
request 
    # Requiere métricas kube-state-metrics + cAdvisor (ya presentes en 
muchos clusters) 
    expr = "quantile_over_time(0.95, 
container_cpu_usage_seconds_total{container!='',pod!='',namespace!='ku
 be-system'}[7d])" 
    # Para simplificar, usamos coste OpenCost como guía de foco (Top 
N) 
    data = opencost_ns(window) 
    top = sorted(data.get("data",[]), key=lambda x: 
x.get("totalCost",0), reverse=True)[:10] 
    recs = [] 
    for ns in top: 
        recs.append({"namespace": ns["name"], "suggestion": "Revisar 
requests/limits; objetivo -20% CPU/Mem si uso p95<50%", 
"potential_saving_usd": round(ns["totalCost"]*0.2*0.3,2)}) 
    return recs 
 
def aws_summary(): 
    # Si hay Athena/CE sería ideal; aquí placeholder de ejemplo via 
env/inputs 
    total = float(os.getenv("AWS_COST_LAST_30D","0")) 
    return {"provider":"aws","total_usd_30d": total} 
def gcp_summary(): 
total = float(os.getenv("GCP_COST_LAST_30D","0")) 
return {"provider":"gcp","total_usd_30d": total} 
def azure_summary(): 
total = float(os.getenv("AZURE_COST_LAST_30D","0")) 
return {"provider":"azure","total_usd_30d": total} 
TEMPLATE = Template("""# GNEW · Reporte FinOps – {{ month }} 
**Objetivo de ahorro:** {{ target_pct*100|round(0) }}% (sin degradar 
SLOs) 
**Resumen 30d:** AWS ${{ aws.total_usd_30d }} | GCP ${{ 
gcp.total_usd_30d }} | Azure ${{ azure.total_usd_30d }} 
## Coste por namespace (Top 10, OpenCost) 
| Namespace | Coste total (USD, 30d) | 
|---|---:| 
{% for ns in top_ns -%} 
| {{ ns.name }} | {{ "%.2f"|format(ns.totalCost) }} | 
{% endfor %} 
## Recomendaciones (guardadas por SLO/error budget) 
{% for s in services -%} - **{{ s.name }}** (SLO {{ "%.2f"|format(s.slo*100) }}%): {% if 
s.allowed %}
 ✅
 OK, margen {{ "%.1f"|format(s.eb*100) }}% — aplicar 
rightsizing escalonado.{% else %}
 ⚠
 Bajo margen ({{ 
"%.1f"|format(s.eb*100) }}%), posponer optimizaciones.{% endif %} 
{% endfor %} 
### Rightsizing sugerido (clusters) 
{% for r in recs -%} - `{{ r.namespace }}` → revisar requests/limits (ahorro estimado **${{ 
r.potential_saving_usd }}**/30d) 
{% endfor %} 
> Nota: No se recomiendan acciones que violen 
`min_error_budget_remaining_pct={{ min_eb }}%`. 
 
""") 
 
def main(): 
    now = datetime.datetime.utcnow() 
    month = now.strftime("%Y-%m") 
    oc = opencost_ns("30d") 
    top_ns = sorted(oc.get("data",[]), key=lambda x: 
x.get("totalCost",0), reverse=True)[:10] 
 
    svc = [] 
    for s in CONF["services"]: 
        ok, avail, eb = slo_ok(s["name"], 
s["slo_availability_target"], "30d") 
        svc.append({"name": s["name"], "allowed": ok, "slo": avail, 
"eb": eb}) 
 
    recs = recommend_rightsize("7d") 
 
    report = TEMPLATE.render( 
        month = month, 
        target_pct = CONF["savings_target_pct"], 
        aws = aws_summary(), 
        gcp = gcp_summary(), 
        azure = azure_summary(), 
        top_ns = top_ns, 
        services = svc, 
        recs = recs, 
        min_eb = CONF["slo"]["min_error_budget_remaining_pct"] 
    ) 
 
    outdir = pathlib.Path("docs/finops/reports"); 
outdir.mkdir(parents=True, exist_ok=True) 
    path = outdir / f"{month}.md" 
    path.write_text(report, encoding="utf-8") 
    print(path) 
 
if __name__ == "__main__": 
    main() 
 
 
Workflow mensual (GitHub Actions) 
Ruta completa: .github/workflows/finops-monthly.yml 
name: FinOps Monthly Report 
on: 
  schedule: 
    - cron: "7 4 1 * *"   # día 1 04:07 UTC 
  workflow_dispatch: {} 
permissions: 
  contents: write 
  id-token: write 
jobs: 
  report: 
    runs-on: ubuntu-latest 
    steps: 
      - uses: actions/checkout@v4 
      - uses: actions/setup-python@v5 
        with: { python-version: "3.12" } 
      - name: Install deps 
        run: | 
          python -m pip install --upgrade pip 
          pip install -r services/finops-report/requirements.txt 
      - name: Env costs (placeholders or read from Athena/BigQuery if 
wired) 
        env: 
          AWS_COST_LAST_30D: ${{ secrets.AWS_COST_LAST_30D }} 
          GCP_COST_LAST_30D: ${{ secrets.GCP_COST_LAST_30D }} 
          AZURE_COST_LAST_30D: ${{ secrets.AZURE_COST_LAST_30D }} 
        run: | 
          echo "Using env placeholders or wire Athena/BQ collection in 
next step." 
      - name: Generate report 
        id: gen 
        run: | 
          python services/finops-report/main.py | tee report_path.txt 
          echo "PATH=$(cat report_path.txt)" >> $GITHUB_OUTPUT 
      - name: Commit report 
        uses: stefanzweifel/git-auto-commit-action@v5 
        with: 
          commit_message: "chore(finops): monthly report" 
          file_pattern: docs/finops/reports/*.md 
      - name: Post to Slack 
        if: env.SLACK_WEBHOOK_URL != '' 
        env: 
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} 
        run: | 
          TEXT=$(tail -n +1 "${{ steps.gen.outputs.PATH }}" | head -n 
30) 
          curl -s -X POST -H 'Content-type: application/json' \ 
            --data "$(jq -Rn --arg t "$TEXT" '{text:$t}')" \ 
            "$SLACK_WEBHOOK_URL" 
 
 
Reglas/Gates de ahorro vs SLO 
Ruta completa: infra/observability/prometheus/rules/finops-slo-guard.yaml 
groups: - name: finops-guards 
  rules: 
  - record: gnew:slo:availability:30d 
    expr: 1 - ( sum(rate(http_requests_total{status=~"5.."}[30d])) / 
sum(rate(http_requests_total[30d])) ) 
  - alert: DoNotOptimizeNow 
    expr: gnew:slo:availability:30d < 0.999 and on() vector(1) 
    for: 10m 
    labels: { severity: info } 
    annotations: 
      summary: "SLO bajo; posponer optimizaciones agresivas." 
 
Playbook de ahorro (conservador → 
agresivo) 
Ruta completa: docs/finops/savings-playbook.md 
# Playbook de optimización de costes 
1) **Conservador** (si EB ≥ 30%): - Rightsizing de requests/limits K8s (-10% a -20%). - Apagado nocturno de entornos no productivos. - Grupos spot/ahorro (EKS nodegroups SPOT ≤ 30% de pool). 
2) **Moderado** (si EB ≥ 40%): - Escalado horizontal vs vertical. - Autoscaling más agresivo (HPA, Karpenter). 
3) **Agresivo** (si EB ≥ 60% y validado): - Spot predominante con interrupción tolerada. - Eliminación de servicios infrautilizados. 
**Regla:** nunca cruzar `min_error_budget_remaining_pct` configurado. 
DoD – Verificación automática 
Ruta completa: scripts/finops/dod-check.sh 
#!/usr/bin/env bash 
set -euo pipefail 
# 1) OpenCost instalado 
kubectl -n opencost get deploy opencost >/dev/null 
# 2) Regla de budgets presente (AWS/GCP/Azure al menos uno) 
test -f infra/finops/aws/budgets.tf || test -f 
infra/finops/gcp/main.tf || test -f infra/finops/azure/main.tf 
# 3) Reporte mensual generable 
python services/finops-report/main.py >/dev/null 
echo "DoD N97 OK 
✅
 " 
 
 
Ejemplo de etiquetas unificadas (K8s y 
Terraform) 
Ruta completa: docs/finops/tags.md 
**Obligatorias:** `project=gnew`, `service`, `env`, `owner`, 
`cost_center`. 
 - **K8s (Deployment metadata.labels):** 
  ```yaml 
  metadata: 
    labels: 
      project: gnew 
      service: gateway 
      env: prod 
      owner: platform 
      cost_center: FIN001 
 
Terraform (módulos): 
 
 tags = { project = "gnew", service = "gateway", env = "prod", owner = 
"platform", cost_center = "FIN001" } 
●  
 --- 
 
## Cómo cumplir el **DoD** (Ahorro ≥ X% sin perder SLOs) 
 
1) **Visibilidad**: OpenCost + CUR/BQ + Budgets (IaC).   
2) **Reportes**: workflow mensual genera 
`docs/finops/reports/YYYY-MM.md` y notifica por Slack.   
3) **Recomendaciones**: `finops-report` propone rightsizing/ahorros, 
**filtradas** por **error budget**.   
4) **Seguimiento**: incluir ahorro aplicado vs proyectado en el 
siguiente reporte (añade sección “Delta real”).   
5) **Guardas**: Prometheus rule `DoNotOptimizeNow` + umbral 
`min_error_budget_remaining_pct`.   
> Ajusta `services/finops-report/config.yaml` (`savings_target_pct`) a 
tu **X%** objetivo.   
> Con esto tendrás **presupuestos y alertas**, **reportes mensuales**, 
**recomendaciones accionables** y **protecciones de SLO**, cumpliendo 
N97. 
Tú dijiste: 
programa a nivel de detalle para GNEW N98 10.8 Seguridad de la cadena de suministro 
(Prompt 98) Objetivo: Integridad desde el código al deploy. Roles: Seguridad, DevOps. Stack: 
SBOM (Syft), SLSA, firmas (Cosign), dependabot. Entregables: Políticas de dependencia, 
verificación de artefactos. DoD: Bloqueo de libs vulnerables; trazabilidad total. 
ChatGPT Plus 
Pensó durante 59s 
Ruta completa: security/supply-chain/README.md 
# GNEW · N98 (10.8) Seguridad de la cadena de suministro 
**Objetivo:** Integridad extremo a extremo desde el código hasta el 
deploy.   
**Roles:** Seguridad, DevOps.   
**Stack:** **SBOM** (Syft), **SLSA** (provenance), **firmas** (Cosign 
keyless), **Dependabot/OSV**. 
## Entregables - **Políticas de dependencia** (Dependabot/OSV, gates CI 
“HIGH/CRITICAL -> fail”). - **SBOM** por imagen (SPDX JSON) + **attestation** OCI. - **SLSA v1 provenance** para imágenes y artefactos. - **Firmas** Sigstore/Cosign (keyless OIDC) y **verificación** en 
deploy. - **Admission control** (Kyverno / Sigstore policy-controller) para 
bloquear imágenes no firmadas o sin SLSA. 
- **Trazabilidad**: commit → imagen(digest) → firma → sbom → slsa → 
release. 
 
## DoD - **Bloqueo** de librerías vulnerables **HIGH/CRITICAL** (build 
falla). - **Verificación de firma + SLSA** en staging/prod. - **Trazabilidad total** (SBOM + provenance adjuntas al artefacto). 
 
 
1) CI: build → SBOM → scan → sign → 
attest (SLSA + SBOM) 
