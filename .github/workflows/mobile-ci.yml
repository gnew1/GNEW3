name: Mobile CI

on:
  pull_request:
    paths: ["apps/mobile/**", ".github/workflows/mobile-ci.yml"]
  push:
    branches: [main]
    paths: ["apps/mobile/**"]

jobs:
  android-detox:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20 }
      - name: Install deps
        working-directory: apps/mobile
        run: |
          npm i -g expo-cli eas-cli
          npm ci
      - name: Android emulator
        uses: reactivecircus/android-emulator-runner@v2
        with:
          api-level: 34
          arch: x86_64
          profile: pixel_5
          script: |
            cd apps/mobile
            npm run build:e2e:android
            npm run test:e2e

 
10) Arquitectura modular (feature based)
●	modules/screens por feature: governance/, wallet/, settings/, auth/, onboarding/.

●	services por capa: api.ts (REST), wallet.ts (key mgmt + firma), notifications.ts (push), auth.ts (SIWE).

●	state: Zustand + React Query; persistencia AsyncStorage para offline first.

●	accesibilidad: roles accessibilityRole, textos claros, tamaños adecuados, contraste (tema).

 
11) Seguridad de claves
●	expo-secure-store con requireAuthentication: true → almacena private key con soporte hardware backed (Keychain/Keystore).

●	Biometría (FaceID/TouchID) con expo-local-authentication en el gate de login y cada uso sensible (signMessage).

●	No sincronizar claves a la nube, no logs de claves, clipboard solo bajo acciones explícitas.

●	Alternativa/complemento: WalletConnect v2 (@walletconnect/modal-react-native) para conectar carteras externas; usar extra.wcProjectId desde secretos de EAS.

 
12) Soporte offline first
●	React Query Persist con AsyncStorage (cache requests críticos: propuestas, perfil, notificaciones).

●	Background fetch (opcional) para refrescar colas de notificaciones on resume; evita polling agresivo → batería controlada.

 
13) Deep links
●	Esquema gnew:// y universal links https://app.gnew.org/*.

●	Navegación mapeada en linking.ts para rutas gov, wallet, etc.

●	Backend debe emitir URLs compatibles en notificaciones para navegación contextual.

 
14) Pruebas / DoD
●	Arranque < 2s (cold start): Hermes, lazy screens, imágenes optimizadas, Metro RAM bundles (Expo optimiza).

●	Consumo batería controlado: sin polling continuo, usar push y staleTime ajustado.

●	Detox E2E smoke: firstRun.e2e.ts (onboarding → login visible).

●	Accesibilidad: controles con accessibilityRole, textos legibles, contraste.

●	Errores/Empty states: mensajes claros en GovernanceScreen.

 
15) Riesgos & Controles
●	Fragmentación SO → CI con emulador Android (API 34) y pruebas en iOS local/EAS; matrices de dispositivos en Play Console/TestFlight.

●	Claves en riesgo → SecureStore + biometría + hardware backed; opción WalletConnect (no custodia).

●	Rendimiento → code splitting (lazy), evitar renders (memo), React Query stale razonable.

●	Push delivery → canal Android por defecto, fallback a in-app banners si sin permisos; monitorización con métricas del backend.

 
Nota Flutter (paridad funcional)
Si prefieres Flutter, replica los módulos: flutter_secure_storage (Keychain/Keystore), local_auth, go_router para deep links, flutter_local_notifications/Firebase Cloud Messaging para push, dio + hive/isar para cache offline, e2e con integration_test y flutter_driver o patrol. La arquitectura y DoD se mantienen.
 
¿Quieres que añada WalletConnect modal en WalletScreen y un screen de Propuesta con voto firmado (SIWE) listo contra tu backend? Puedo entregarlo enseguida.
Tú dijiste:
programa a nivel de detalle para GNEW N53 6.3 Onboarding guiado (Prompt 53) Objetivo: Flujo paso a paso que reduzca fricción y enseñe el valor. Roles: Producto, UX Writer, Frontend, Data. Stack: React “guided tours”, feature flags, analítica (Amplitude/Heap), i18n. Entregables: Asistente de onboarding, checklist inicial, progresos guardados. Pasos: Segmentar por perfil (novato, dev, validador, creador). Misiones iniciales con recompensas simbólicas. Guardar progreso y permitir “skip” sin perder info. Pruebas / DoD: Conversión onboarding→actividad ≥ X%, tiempo medio ≤ N min. Riesgos & Controles: Sobrecarga cognitiva → micro-tareas; abandono → re-engagement por correo/push.
ChatGPT Plus
Pensó durante 46s
Listo. Entrego el programa a nivel de detalle y entrega para GNEW · N53 — Onboarding guiado, con rutas completas y código listo para integrar en apps/web (stack React + i18n + feature flags + analítica Amplitude/Heap). Incluye asistente paso a paso, checklist inicial, progreso persistente (localStorage + sync opcional), segmentación por perfil, misiones con recompensas simbólicas, deep links y eventos de conversión.
 
0) Dependencias (añadir al paquete web)
Ruta completa: apps/web/package.json (añade estas deps a las existentes)
{
  "dependencies": {
    "@amplitude/analytics-browser": "2.11.9",
    "react-joyride": "2.9.3"
  }
}

 
1) Flags (feature flags client) + i18n + analytics
Ruta completa: apps/web/src/flags/flags.ts
export type Flags = {
  onboardingEnabled: boolean;
  guidedToursEnabled: boolean;
  rewardsEnabled: boolean;
};

export const defaultFlags: Flags = {
  onboardingEnabled: true,
  guidedToursEnabled: true,
  rewardsEnabled: true
};

Ruta completa: apps/web/src/flags/FlagsProvider.tsx
import React, { createContext, useContext, useEffect, useState } from "react";
import { Flags, defaultFlags } from "./flags";

const FlagsCtx = createContext<Flags>(defaultFlags);

export function FlagsProvider({ children }: { children: React.ReactNode }) {
  const [flags, setFlags] = useState<Flags>(defaultFlags);

  useEffect(() => {
    // Intenta cargar flags remotos (e.g. /api/flags), con fallback a defaults.
    (async () => {
      try {
        const res = await fetch("/api/flags");
        if (res.ok) {
          const f = await res.json();
          setFlags({ ...defaultFlags, ...f });
        }
      } catch { /* noop */ }
    })();
  }, []);

  return <FlagsCtx.Provider value={flags}>{children}</FlagsCtx.Provider>;
}
export const useFlags = () => useContext(FlagsCtx);

Ruta completa: apps/web/src/lib/analytics.ts
import * as amp from "@amplitude/analytics-browser";

let initialized = false;

export function initAnalytics(apiKey?: string) {
  if (initialized) return;
  const key = apiKey || (import.meta.env.VITE_AMPLITUDE_KEY as string);
  if (key) {
    amp.init(key, undefined, { defaultTracking: { sessions: true, pageViews: true } });
    initialized = true;
  }
  // HEAP opcional: pega tu snippet en index.html o aquí vía dynamic script si se requiere.
}

export function track(event: string, props?: Record<string, any>) {
  if (!initialized) return;
  amp.track(event, props);
}

Ruta completa: apps/web/src/lib/i18n.ts (extiende lo existente con claves de onboarding)
// ...importes existentes...
const resources = {
  es: {
    translation: {
      // ...claves existentes...
      onboarding: {
        title: "Bienvenido a GNEW",
        chooseProfile: "Elige tu perfil",
        profiles: { newbie: "Novato", dev: "Dev", validator: "Validador", creator: "Creador" },
        checklistTitle: "Checklist inicial",
        start: "Empezar",
        skip: "Saltar y continuar",
        resume: "Continuar",
        done: "Hecho",
        tour: { next: "Siguiente", back: "Atrás", skip: "Saltar tour", close: "Cerrar" },
        rewards: { earned: "Recompensa obtenida", points: "{{n}} pts" }
      }
    }
  },
  en: {
    translation: {
      onboarding: {
        title: "Welcome to GNEW",
        chooseProfile: "Choose your profile",
        profiles: { newbie: "Newbie", dev: "Dev", validator: "Validator", creator: "Creator" },
        checklistTitle: "Starter checklist",
        start: "Start",
        skip: "Skip",
        resume: "Resume",
        done: "Done",
        tour: { next: "Next", back: "Back", skip: "Skip tour", close: "Close" },
        rewards: { earned: "Reward earned", points: "{{n}} pts" }
      }
    }
  }
};
// init con estos resources como en N51

 
2) Definiciones, misiones y segmentación
Ruta completa: apps/web/src/modules/onboarding/types.ts
export type Profile = "newbie" | "dev" | "validator" | "creator";

export type Mission = {
  id: string;
  title: string;
  description: string;
  points: number;
  ctaLabel: string;
  // Acción: URL interna, callback, o deep-link
  action: { type: "route"; to: string } | { type: "callback"; id: string };
  // evento de analítica a emitir cuando se completa
  analyticsEvent: string;
};

export type OnboardingState = {
  profile: Profile | null;
  completed: string[]; // ids de misiones completadas
  points: number;
  lastStep?: number; // para wizard
};

Ruta completa: apps/web/src/modules/onboarding/constants.ts
import { Mission, Profile } from "./types";

export const PROFILE_MISSIONS: Record<Profile, Mission[]> = {
  newbie: [
    {
      id: "nb_create_wallet",
      title: "Crea tu billetera",
      description: "Genera una wallet y respáldala.",
      points: 50,
      ctaLabel: "Ir a Billetera",
      action: { type: "route", to: "/wallet" },
      analyticsEvent: "onb_mission_wallet_done"
    },
    {
      id: "nb_vote_first",
      title: "Emite tu primer voto",
      description: "Participa en una propuesta activa.",
      points: 70,
      ctaLabel: "Ir a Gobernanza",
      action: { type: "route", to: "/dashboard" },
      analyticsEvent: "onb_mission_first_vote_done"
    }
  ],
  dev: [
    {
      id: "dev_get_api_key",
      title: "Obtén tu API key",
      description: "Solicita una API key para integrar.",
      points: 40,
      ctaLabel: "Ver APIs",
      action: { type: "route", to: "/docs/apis" },
      analyticsEvent: "onb_mission_api_key_done"
    },
    {
      id: "dev_run_sdk",
      title: "Ejecuta el SDK",
      description: "Prueba un ejemplo con el SDK.",
      points: 80,
      ctaLabel: "Abrir Quickstart",
      action: { type: "route", to: "/docs/quickstart" },
      analyticsEvent: "onb_mission_sdk_done"
    }
  ],
  validator: [
    {
      id: "val_stake",
      title: "Haz stake inicial",
      description: "Delega o valida con stake.",
      points: 100,
      ctaLabel: "Ir a Staking",
      action: { type: "route", to: "/staking" },
      analyticsEvent: "onb_mission_stake_done"
    }
  ],
  creator: [
    {
      id: "cr_create_proposal",
      title: "Crea tu primera propuesta",
      description: "Crea una propuesta y compártela.",
      points: 120,
      ctaLabel: "Nueva Propuesta",
      action: { type: "route", to: "/proposals/new" },
      analyticsEvent: "onb_mission_create_proposal_done"
    }
  ]
};

 
3) Progreso persistente (localStorage + sync opcional)
Ruta completa: apps/web/src/modules/onboarding/useOnboardingProgress.ts
import { useCallback, useEffect, useState } from "react";
import { OnboardingState, Profile } from "./types";
import { track } from "@lib/analytics";

const KEY = "gnew:onboarding:v1";

function load(): OnboardingState {
  try {
    const raw = localStorage.getItem(KEY);
    if (raw) return JSON.parse(raw);
  } catch {}
  return { profile: null, completed: [], points: 0, lastStep: 0 };
}
function save(s: OnboardingState) {
  localStorage.setItem(KEY, JSON.stringify(s));
}

export function useOnboardingProgress() {
  const [state, setState] = useState<OnboardingState>(() => load());

  useEffect(() => { save(state); }, [state]);

  const setProfile = useCallback((p: Profile) => {
    setState((s) => ({ ...s, profile: p }));
    track("onb_profile_set", { profile: p });
  }, []);

  const complete = useCallback((missionId: string, points: number, event: string) => {
    setState((s) => {
      if (s.completed.includes(missionId)) return s;
      const next = { ...s, completed: [...s.completed, missionId], points: s.points + points };
      return next;
    });
    track(event, { missionId, points });
  }, []);

  const reset = useCallback(() => {
    const base = { profile: null, completed: [], points: 0, lastStep: 0 };
    setState(base);
    save(base);
  }, []);

  const setLastStep = useCallback((i: number) => setState((s) => ({ ...s, lastStep: i })), []);

  return { state, setProfile, complete, reset, setLastStep };
}

 
4) Asistente (wizard), Checklist y Guided Tour
Ruta completa: apps/web/src/modules/onboarding/GuidedTour.tsx
import React from "react";
import Joyride, { CallBackProps, Step } from "react-joyride";
import { useTranslation } from "react-i18next";
import { useFlags } from "@flags/FlagsProvider";
import { track } from "@lib/analytics";

export function GuidedTour({ run, steps }: { run: boolean; steps: Step[] }) {
  const { t } = useTranslation();
  const { guidedToursEnabled } = useFlags();

  if (!guidedToursEnabled) return null;

  const handle = (e: CallBackProps) => {
    if (e.status === "finished") track("onb_tour_finished");
    if (e.status === "skipped") track("onb_tour_skipped");
  };

  return (
    <Joyride
      run={run}
      steps={steps}
      locale={{ back: t("onboarding.tour.back"), close: t("onboarding.tour.close"), last: t("onboarding.done"), next: t("onboarding.tour.next"), skip: t("onboarding.tour.skip") }}
      showSkipButton
      continuous
      disableOverlayClose
      callback={handle}
      styles={{
        options: { primaryColor: "#5b9dff", zIndex: 10000 }
      }}
    />
  );
}

Ruta completa: apps/web/src/modules/onboarding/OnboardingChecklist.tsx
import React from "react";
import { useTranslation } from "react-i18next";
import { Mission } from "./types";
import { useNavigate } from "react-router-dom";

export function OnboardingChecklist({
  missions,
  completed,
  onAction
}: {
  missions: Mission[];
  completed: string[];
  onAction: (m: Mission) => void;
}) {
  const { t } = useTranslation();
  const nav = useNavigate();

  return (
    <section className="card" role="region" aria-label={t("onboarding.checklistTitle")!}>
      <h3 style={{ marginTop: 0 }}>{t("onboarding.checklistTitle")}</h3>
      <ul style={{ listStyle: "none", padding: 0, margin: 0, display: "grid", gap: 12 }}>
        {missions.map((m) => {
          const done = completed.includes(m.id);
          return (
            <li key={m.id} className="row" style={{ justifyContent: "space-between", alignItems: "center" }}>
              <div>
                <div style={{ fontWeight: 700 }}>{m.title}</div>
                <div style={{ color: "var(--fg-muted)", fontSize: 14 }}>{m.description}</div>
              </div>
              <div className="row" style={{ gap: 8 }}>
                <span aria-live="polite" style={{ color: done ? "var(--fg-success)" : "var(--fg-muted)" }}>
                  {done ? "✓" : `+${m.points}`}
                </span>
                {!done ? (
                  <button
                    className="button"
                    onClick={() => (m.action.type === "route" ? nav(m.action.to) : onAction(m))}
                    aria-label={`Completar ${m.title}`}
                    style={{ padding: "6px 10px", borderRadius: 8, border: "1px solid #334", background: "var(--bg-elevated)", color: "var(--fg-primary)" }}
                  >
                    {m.ctaLabel}
                  </button>
                ) : null}
              </div>
            </li>
          );
        })}
      </ul>
    </section>
  );
}

Ruta completa: apps/web/src/modules/onboarding/OnboardingWizard.tsx
import React, { useMemo, useState } from "react";
import { useTranslation } from "react-i18next";
import { useOnboardingProgress } from "./useOnboardingProgress";
import { PROFILE_MISSIONS } from "./constants";
import { Profile } from "./types";
import { GuidedTour } from "./GuidedTour";
import { useFlags } from "@flags/FlagsProvider";
import { track } from "@lib/analytics";

export default function OnboardingWizard() {
  const { t } = useTranslation();
  const { state, setProfile, complete, setLastStep } = useOnboardingProgress();
  const { onboardingEnabled, rewardsEnabled } = useFlags();
  const [tourRun, setTourRun] = useState(false);

  const steps = useMemo(
    () => [
      { target: "body", placement: "center", content: (<div><h3>{t("onboarding.title")}</h3><p>{t("onboarding.chooseProfile")}</p></div>) },
      { target: "[data-tour='nav-dashboard']", content: "Aquí verás tu panel y propuestas activas." },
      { target: "[data-tour='nav-wallet']", content: "Gestiona tu billetera desde aquí." }
    ],
    [t]
  );

  if (!onboardingEnabled) return null;

  const startTour = () => { setTourRun(true); track("onb_tour_started"); };

  const onSelectProfile = (p: Profile) => {
    setProfile(p);
    setLastStep(1);
    startTour();
  };

  const missions = state.profile ? PROFILE_MISSIONS[state.profile] : [];

  const onAction = (m: (typeof missions)[number]) => {
    // Si la misión es de acción "callback" podríamos implementarla aquí.
    // Como ejemplo, la marcamos como completada inmediatamente:
    complete(m.id, m.points, m.analyticsEvent);
    if (rewardsEnabled) {
      // Mostrar badge de recompensa (simple alert)
      alert(`${t("onboarding.rewards.earned")} · ${t("onboarding.rewards.points", { n: m.points })}`);
    }
  };

  const ConversionBar = () => (
    <div className="card" aria-live="polite" style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
      <div>Progreso: {state.completed.length} / {missions.length} misiones · Puntos: {state.points}</div>
      <div className="row" style={{ gap: 8 }}>
        <a className="button" href="/" aria-label={t("onboarding.skip")!}>{t("onboarding.skip")}</a>
        <button className="button" onClick={() => startTour()}>{t("onboarding.resume")}</button>
      </div>
    </div>
  );

  return (
    <div className="container" style={{ display: "grid", gap: 16 }}>
      <GuidedTour run={tourRun} steps={steps as any} />
      {!state.profile ? (
        <section className="card" role="region" aria-label={t("onboarding.chooseProfile")!}>
          <h2 style={{ marginTop: 0 }}>{t("onboarding.chooseProfile")}</h2>
          <div className="grid" style={{ gridTemplateColumns: "repeat(auto-fit,minmax(220px,1fr))" }}>
            {([
              ["newbie", "🧭", "Primeros pasos"],
              ["dev", "👩‍💻", "Desarrollador"],
              ["validator", "🛡️", "Validador"],
              ["creator", "📝", "Creador"]
            ] as const).map(([p, icon, label]) => (
              <button key={p} onClick={() => onSelectProfile(p)} className="card" aria-label={label} style={{ textAlign: "left" }}>
                <div style={{ fontSize: 28 }}>{icon}</div>
                <div style={{ fontWeight: 700 }}>{label}</div>
              </button>
            ))}
          </div>
        </section>
      ) : (
        <>
          <ConversionBar />
          <section className="card" role="region" aria-label="Resumen">
            <h2 style={{ marginTop: 0 }}>{t("onboarding.title")}</h2>
            <p>Perfil seleccionado: <strong>{state.profile}</strong></p>
          </section>
          <section>
            <OnboardingChecklist missions={missions} completed={state.completed} onAction={onAction} />
          </section>
        </>
      )}
    </div>
  );
}

Ruta completa: apps/web/src/modules/onboarding/index.ts
export { default as OnboardingWizard } from "./OnboardingWizard";

 
5) Integración de rutas y layout (añade entrada “Onboarding”)
Ruta completa: apps/web/src/router/guards.tsx (añade la ruta pública /onboarding)
import React, { Suspense } from "react";
import { createBrowserRouter } from "react-router-dom";
import { AppLayout } from "@modules/core/layout/AppLayout";
import { ProtectedRoute } from "./ProtectedRoute";
import { Forbidden } from "@modules/errors/Forbidden";
import { NotFound } from "@modules/errors/NotFound";
import { OnboardingWizard } from "@modules/onboarding";

const Home = React.lazy(() => import("@modules/core/pages/Home"));
const Login = React.lazy(() => import("@modules/auth/pages/Login"));

export const router = createBrowserRouter([
  {
    path: "/",
    element: <AppLayout />,
    children: [
      { index: true, element: <Suspense fallback={<div>…</div>}><Home /></Suspense> },
      { path: "onboarding", element: <OnboardingWizard /> },
      {
        element: <ProtectedRoute roles={["member", "admin"]} />,
        children: [
          { path: "dashboard", element: <div className="container" data-tour="nav-dashboard">Dashboard</div> },
          { path: "wallet", element: <div className="container" data-tour="nav-wallet">Wallet</div> }
        ]
      },
      { path: "login", element: <Suspense fallback={<div>…</div>}><Login /></Suspense> },
      { path: "forbidden", element: <Forbidden /> },
      { path: "*", element: <NotFound /> }
    ]
  }
]);

Ruta completa: apps/web/src/main.tsx (inyecta FlagsProvider + init analytics)
import React, { useEffect } from "react";
import ReactDOM from "react-dom/client";
import { RouterProvider } from "react-router-dom";
import { QueryClientProvider } from "@tanstack/react-query";
import { router } from "@router/guards";
import { queryClient } from "@lib/queryClient";
import "./global.css";
import "./lib/i18n";
import { FlagsProvider } from "@flags/FlagsProvider";
import { initAnalytics } from "@lib/analytics";

function Root() {
  useEffect(() => { initAnalytics(); }, []);
  return (
    <QueryClientProvider client={queryClient}>
      <FlagsProvider>
        <RouterProvider router={router} />
      </FlagsProvider>
    </QueryClientProvider>
  );
}
ReactDOM.createRoot(document.getElementById("root")!).render(<React.StrictMode><Root /></React.StrictMode>);

 
6) API mínima para flags (opcional, demo reproducible)
Ruta completa: apps/web/pages/api/flags.ts
import type { NextApiRequest, NextApiResponse } from "next";

// Puedes parametrizar por usuario, cohortes o remote config.
// Demo: activar todo.
export default async function handler(_req: NextApiRequest, res: NextApiResponse) {
  res.status(200).json({
    onboardingEnabled: true,
    guidedToursEnabled: true,
    rewardsEnabled: true
  });
}

 
7) Estilos mínimos (botón utilitario para checklist)
Ruta completa: apps/web/src/styles/utility.css (si no existía, añade la clase)
.button {
  background: var(--fg-brand);
  color: #0b1324;
  border: 1px solid transparent;
  padding: 8px 12px;
  border-radius: var(--radius-md);
  cursor: pointer;
}
.button:hover { opacity: .9; }

Asegúrate de tener @import "@styles/utility.css"; en global.css.
 
8) Métricas de conversión y eventos (Amplitude/Heap)
Eventos emitidos (ver lib/analytics.ts y llamadas en wizard):
●	onb_profile_set — { profile }

●	onb_tour_started / onb_tour_finished / onb_tour_skipped

●	onb_mission_*_done — { missionId, points }

●	Conversión: calcular onboarding→actividad como usuarios con onb_mission_*_done ∧ evento “actividad clave” (p.ej. vote_cast o wallet_created) en T+7 días. Definir en Amplitude un Funnel.

●	Tiempo medio: marcar onb_profile_set como inicio y el primer onb_mission_*_done como fin; usar Time to convert en Amplitude para medir ≤ N min objetivo.

 
9) Re-engagement (abandono)
●	Si el usuario salta (Skip) o cierra el tour sin completar misiones → emitir onb_tour_skipped.

●	Backend/CRM: dispara correo/push con deep link https://app.gnew.org/onboarding que reabre el wizard (la ruta ya existe).

●	Guardado de progreso: localStorage mantiene perfil/estado; al volver, muestra “Continuar”.

 
10) Pruebas / DoD
Definición de Done:
●	✅ Asistente de onboarding accesible en /onboarding, con tour (Joyride) y checklist por perfil.

●	✅ Progreso persistente (localStorage) y Skip no pierde el estado.

●	✅ Segmentación: 4 perfiles (novato/dev/validador/creador) con misiones y recompensas simbólicas (puntos).

●	✅ i18n completo (ES/EN) y a11y (roles aria, labels, focus visible).

●	✅ Feature flags para activar/desactivar onboarding/tours/recompensas.

●	✅ Analítica: eventos instrumentados; documentación de funnel (onboarding→actividad ≥ X%) y time to convert ≤ N min.

●	✅ Demo reproducible en entorno limpio (sin backend): flags desde /api/flags, estado en localStorage.

(Sustituye X y N por metas de negocio; p.ej., X ≥ 45%, N ≤ 3 min.)
 
11) Riesgos & Controles
●	Sobrecarga cognitiva → micro tareas (misiones < 1 min), pasos del tour ≤ 3 por sesión, checklist visible y clara.

●	Abandono → re engagement con email/push (deep link a /onboarding), recordatorios espaciados (no spam).

●	Segmentación errónea → permitir cambiar de perfil sin perder puntos (botón “Cambiar perfil” opcional).

●	Privacidad → no guardar PII en localStorage; sólo profile, completed, points. IDs de misiones no sensibles.

●	Medición sesgada → auditar eventos con QA (correlación entre UI y eventos), validación en Amplitude/Heap.

 
12) (Opcional) Test unitario del progreso
Ruta completa: apps/web/src/modules/onboarding/useOnboardingProgress.test.ts
import { describe, it, expect } from "vitest";
import { renderHook, act } from "@testing-library/react";
import { useOnboardingProgress } from "./useOnboardingProgress";

// Mock de localStorage para entorno de test si fuera necesario
Object.defineProperty(global, "localStorage", {
  value: {
    data: {} as Record<string, string>,
    getItem(k: string) { return this.data[k]; },
    setItem(k: string, v: string) { this.data[k] = v; }
  }
});

describe("useOnboardingProgress", () => {
  it("sets profile and completes missions with points", () => {
    const { result } = renderHook(() => useOnboardingProgress() as any);
    act(() => result.current.setProfile("newbie"));
    expect(result.current.state.profile).toBe("newbie");
    act(() => result.current.complete("m1", 50, "evt"));
    expect(result.current.state.points).toBe(50);
    expect(result.current.state.completed).toContain("m1");
  });
});

 
13) Notas de integración
●	Navbar/Sidebar: añade data-tour="nav-dashboard" y data-tour="nav-wallet" (ya en el router) para que el Tour apunte a elementos reales.

●	Recompensas reales: si más adelante quieres canjeables, expón /api/rewards/claim y sustituye el alert por una petición real.

●	Feature flags remotos: integrar con Unleash/Flagsmith/LD llamando desde FlagsProvider y segmentando por perfil/rollout.

 
¿Quieres que conecte el tour a pantallas reales (dashboard/wallet del N51) y deje configurado Lighthouse CI para medir el tiempo del flujo? Puedo añadirlo ahora.
Tú dijiste:
programa a nivel de detalle para gnew N54 6.4 Tutoriales y micro-learning (Prompt 54) Objetivo: Contenido interactivo y vídeos cortos integrados. Roles: Educación, Frontend, Video, Localización. Stack: MDX/Docusaurus embebido, reproductor ligero, tracking SCORM-lite. Entregables: Biblioteca de tutoriales, rutas de aprendizaje por rol. Pasos: Plantillas MDX con quizzes. Progreso on-chain opcional (soulbound badges). Indexación y búsqueda semántica. Pruebas / DoD: Tasa de finalización ≥ X%, satisfacción ≥ Y/5. Riesgos & Controles: Desactualización → versionado y “last reviewed”.
ChatGPT Plus
Pensó durante 53s
Perfecto. Entrego el programa a nivel de detalle y entrega para GNEW · N54 — Tutoriales y micro learning, con rutas completas y código listo para integrar en apps/web (MDX embebido, reproductor ligero, i18n y “SCORM lite” para tracking), biblioteca de tutoriales, rutas de aprendizaje por rol, quizzes, progreso on chain opcional (soulbound badges), e indexación/búsqueda semántica.
 
Dependencias y build
Ruta completa: apps/web/package.json (añade/actualiza estas entradas)
{
  "dependencies": {
    "@amplitude/analytics-browser": "2.11.9",
    "@mdx-js/react": "3.0.1",
    "@xenova/transformers": "2.16.1",
    "gray-matter": "4.0.3",
    "rehype-slug": "6.0.0",
    "remark-gfm": "4.0.0",
    "remark-frontmatter": "5.0.0"
  },
  "devDependencies": {
    "@mdx-js/rollup": "3.0.1"
  }
}

Ruta completa: apps/web/vite.config.ts (añade soporte MDX)
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import { VitePWA } from "@vite-pwa/vite-plugin";
import mdx from "@mdx-js/rollup";
import remarkGfm from "remark-gfm";
import remarkFrontmatter from "remark-frontmatter";
import rehypeSlug from "rehype-slug";

export default defineConfig({
  plugins: [
    react(),
    mdx({ remarkPlugins: [remarkGfm, remarkFrontmatter], rehypePlugins: [rehypeSlug] }),
    VitePWA({
      registerType: "autoUpdate",
      includeAssets: ["favicon.svg"],
      manifest: {
        name: "GNEW Web",
        short_name: "GNEW",
        theme_color: "#0b1324",
        background_color: "#0b1324",
        display: "standalone",
        start_url: "/",
        icons: [
          { src: "/icons/icon-192.png", sizes: "192x192", type: "image/png" },
          { src: "/icons/icon-512.png", sizes: "512x512", type: "image/png" }
        ]
      }
    })
  ],
  server: { port: 5173 },
  build: { sourcemap: true, target: "es2022" }
});

 
Contenido MDX (plantillas con quizzes, vídeo y metadatos)
Ruta completa: apps/web/content/tutorials/README.md
# Contenido de Tutoriales (MDX)
- Usa **frontmatter** con: `title`, `slug`, `role`, `duration`, `version`, `lastReviewed`, `tags`.
- Componentes MDX disponibles: `<Quiz>`, `<VideoPlayer>`, `<Callout>`, `<BadgeClaim>`.
- SCORM-lite: progress y score por `slug`.

Ruta completa: apps/web/content/tutorials/intro-governanza.mdx
---
title: "Introducción a la Gobernanza"
slug: "intro-governanza"
role: "newbie"
duration: 6
version: "1.0.0"
lastReviewed: "2025-08-01"
tags: ["gobernanza","votos","propuestas"]
---

import { Quiz, VideoPlayer, Callout, BadgeClaim } from "@modules/learn/mdx";

# {frontmatter.title}

<Callout type="info">
Este micro tutorial te muestra cómo votar una propuesta y por qué importa.
</Callout>

<VideoPlayer src="/videos/intro-governanza.mp4" poster="/videos/poster-governanza.jpg" />

## Claves
- Qué es una **propuesta**
- Cómo emitir un **voto**
- Señales básicas del **cuórum**

<Quiz id="q1"
  question="¿Cuándo se alcanza el cuórum?"
  options={[
    "Cuando la mayoría simple vota",
    "Cuando se alcanza el umbral definido por el protocolo",
    "Cuando hay al menos 10 votos"
  ]}
  correct={1}
  feedback={[
    "La mayoría simple puede no ser suficiente.",
    "¡Correcto! El umbral varía por protocolo.",
    "No necesariamente."
  ]}
/>

<BadgeClaim
  badgeId="GNEW101"
  minScore={70}
  text="Reclamar insignia (soulbound) por completar el 70%."
/>

Ruta completa: apps/web/content/tutorials/dev-sdk-quickstart.mdx
---
title: "Quickstart SDK para Devs"
slug: "dev-sdk-quickstart"
role: "dev"
duration: 8
version: "1.1.0"
lastReviewed: "2025-07-15"
tags: ["sdk","apis","dev"]
---

import { Quiz, Callout } from "@modules/learn/mdx";

# {frontmatter.title}

Instala el SDK y dispara tu primer request.

```bash
pnpm add @gnew/sdk

<Callout type="warning">Usa claves de prueba, nunca publiques secretos.</Callout>
<Quiz id="q-sdk"
 question="¿Dónde se deben guardar las API keys?"
 options={["En el repo", "En variables de entorno / vaults", "En el frontend"]}
 correct={1}
 feedback={["Riesgo de filtración crítico.", "¡Correcto!", "No debe exponerse en el cliente."]}
 />

---

# Catálogo, rutas y UI de aprendizaje

**Ruta completa: `apps/web/src/modules/learn/catalog.ts`**
```ts
// Descubre MDX por globs y expone metadatos estáticos para el catálogo.
export type MDXModule = { default: any; frontmatter: any };
export type TutorialMeta = {
  title: string; slug: string; role: "newbie" | "dev" | "validator" | "creator";
  duration: number; version: string; lastReviewed: string; tags?: string[];
};

const modules = import.meta.glob<MDXModule>("/apps/web/content/tutorials/*.mdx", { eager: true });

export const tutorials: TutorialMeta[] = Object.values(modules).map((m: any) => m.frontmatter as TutorialMeta)
  .sort((a, b) => a.title.localeCompare(b.title));

export function getBySlug(slug: string): { meta: TutorialMeta; mod: MDXModule } | null {
  for (const [path, mod] of Object.entries(modules)) {
    if ((mod as any).frontmatter?.slug === slug) return { meta: (mod as any).frontmatter, mod: mod as any };
  }
  return null;
}

export const pathsByRole: Record<TutorialMeta["role"], string[]> = {
  newbie: ["intro-governanza"],
  dev: ["dev-sdk-quickstart"],
  validator: [],
  creator: []
};

Ruta completa: apps/web/src/modules/learn/mdx/index.tsx (componentes MDX disponibles)
import React, { useMemo } from "react";
import { useScorm } from "../scorm/ScormProvider";
import { track } from "@lib/analytics";

export function Callout({ type = "info", children }: { type?: "info"|"warning"|"success"; children: React.ReactNode }) {
  const colors: Record<string,string> = { info: "#1e90ff", warning: "#f1c40f", success: "#2ecc71" };
  return (
    <div style={{ borderLeft: `4px solid ${colors[type]}`, padding: 12, background: "var(--bg-elevated)", borderRadius: 8, margin: "12px 0" }}>
      {children}
    </div>
  );
}

export function VideoPlayer({ src, poster }: { src: string; poster?: string }) {
  // Reproductor HTML5 ligero (usa HLS nativo iOS; para m3u8 en desktop, integrar hls.js si se requiere)
  return (
    <video
      src={src}
      poster={poster}
      controls
      preload="metadata"
      style={{ width: "100%", borderRadius: 12, outline: "none" }}
    />
  );
}

export function Quiz({
  id, question, options, correct, feedback
}: { id: string; question: string; options: string[]; correct: number; feedback: string[] }) {
  const { registerQuiz, answerQuiz, state } = useScorm();
  const answered = state.answers[id];
  useMemo(() => registerQuiz(id, options.length, correct), [id]);

  return (
    <div className="card" role="group" aria-label={`Quiz ${id}`} style={{ margin: "16px 0" }}>
      <strong>{question}</strong>
      <ul style={{ listStyle: "none", padding: 0 }}>
        {options.map((opt, idx) => (
          <li key={idx} style={{ marginTop: 8 }}>
            <button
              className="button"
              disabled={answered !== undefined}
              onClick={() => {
                answerQuiz(id, idx);
                track("learn_quiz_answered", { id, idx });
              }}
            >
              {opt}
            </button>
            {answered !== undefined && idx === answered && (
              <div style={{ marginTop: 6, color: idx === correct ? "var(--fg-success)" : "var(--fg-warning)" }}>
                {feedback?.[idx] || (idx === correct ? "Correcto" : "Incorrecto")}
              </div>
            )}
          </li>
        ))}
      </ul>
    </div>
  );
}

export function BadgeClaim({ badgeId, minScore = 70, text = "Reclamar insignia" }:{
  badgeId: string; minScore?: number; text?: string;
}) {
  const { scorePct, claimBadge } = useScorm();
  const can = scorePct >= minScore;
  return (
    <button className="button" disabled={!can} onClick={() => claimBadge(badgeId)}>
      {text} · {Math.round(scorePct)}%
    </button>
  );
}

Ruta completa: apps/web/src/modules/learn/scorm/ScormProvider.tsx (SCORM lite: progreso, tiempo, score)
import React, { createContext, useContext, useEffect, useRef, useState } from "react";
import { track } from "@lib/analytics";
import { claimSoulbound } from "../services/badges";

type Answers = Record<string, number | undefined>;
type ScormState = {
  startedAt?: number;
  finishedAt?: number;
  answers: Answers;
  totalQuestions: number;
  totalCorrect: number;
};
type Ctx = {
  state: ScormState;
  scorePct: number;
  start: () => void;
  finish: () => void;
  registerQuiz: (id: string, n: number, correctIndex: number) => void;
  answerQuiz: (id: string, idx: number) => void;
  claimBadge: (badgeId: string) => Promise<void>;
};
const ScormCtx = createContext<Ctx>(null as any);

const key = (slug: string) => `gnew:learn:${slug}`;

export function ScormProvider({ slug, children }: { slug: string; children: React.ReactNode }) {
  const [state, setState] = useState<ScormState>(() => {
    try { return JSON.parse(localStorage.getItem(key(slug)) || "null") || { answers: {}, totalQuestions: 0, totalCorrect: 0 }; }
    catch { return { answers: {}, totalQuestions: 0, totalCorrect: 0 }; }
  });
  const correctMap = useRef<Record<string, number>>({});

  const persist = (s: ScormState) => localStorage.setItem(key(slug), JSON.stringify(s));

  useEffect(() => { persist(state); }, [state]);

  const start = () => {
    if (!state.startedAt) {
      const s = { ...state, startedAt: Date.now() }; setState(s); persist(s);
      track("learn_started", { slug });
    }
  };
  const finish = () => {
    if (!state.finishedAt) {
      const s = { ...state, finishedAt: Date.now() }; setState(s); persist(s);
      track("learn_finished", { slug, scorePct: scorePct(s) });
    }
  };

  const registerQuiz = (id: string, n: number, correctIndex: number) => {
    correctMap.current[id] = correctIndex;
    setState((s) => ({ ...s, totalQuestions: Math.max(s.totalQuestions, Object.keys(correctMap.current).length) }));
  };

  const answerQuiz = (id: string, idx: number) => {
    setState((s) => {
      const prev = s.answers[id]; if (prev !== undefined) return s;
      const isCorrect = correctMap.current[id] === idx;
      return { ...s, answers: { ...s.answers, [id]: idx }, totalCorrect: s.totalCorrect + (isCorrect ? 1 : 0) };
    });
  };

  const scorePct = (s = state) => s.totalQuestions === 0 ? 0 : (s.totalCorrect / s.totalQuestions) * 100;

  const claimBadge = async (badgeId: string) => {
    const pct = scorePct();
    track("learn_badge_claim_attempt", { slug, badgeId, pct });
    if (pct < 1) return;
    await claimSoulbound({ badgeId, slug, score: Math.round(pct) });
    track("learn_badge_claimed", { slug, badgeId, pct });
  };

  return (
    <ScormCtx.Provider value={{ state, scorePct: scorePct(), start, finish, registerQuiz, answerQuiz, claimBadge }}>
      {children}
    </ScormCtx.Provider>
  );
}

export function useScorm() { return useContext(ScormCtx); }

Ruta completa: apps/web/src/modules/learn/services/badges.ts (progreso on chain opcional)
import { ethers } from "ethers";

// Configurable por env / Flags
const BADGE_CONTRACT = (import.meta.env.VITE_BADGE_ADDRESS as string) || "";
const ABI = [
  "function claim(address to, string badgeId, string slug, uint256 score) external",
  "function hasBadge(address who, string badgeId) public view returns (bool)"
];

export async function claimSoulbound({ badgeId, slug, score }:{ badgeId: string; slug: string; score: number; }) {
  if (!BADGE_CONTRACT) throw new Error("Badge contract no configurado");
  if (!(window as any).ethereum) throw new Error("Wallet no disponible");
  const provider = new ethers.BrowserProvider((window as any).ethereum);
  const signer = await provider.getSigner();
  const contract = new ethers.Contract(BADGE_CONTRACT, ABI, signer);
  const addr = await signer.getAddress();
  const has = await contract.hasBadge(addr, badgeId);
  if (has) return;
  const tx = await contract.claim(addr, badgeId, slug, score);
  await tx.wait();
}

Ruta completa: apps/web/src/modules/learn/pages/Library.tsx
import React, { useMemo, useState } from "react";
import { tutorials, pathsByRole, TutorialMeta } from "../catalog";
import { Link } from "react-router-dom";
import { searchQuery } from "../search/search";

export default function Library() {
  const [q, setQ] = useState("");
  const [role, setRole] = useState<"all"|"newbie"|"dev"|"validator"|"creator">("all");
  const list = useMemo(() => {
    const base = role === "all" ? tutorials : tutorials.filter(t => t.role === role);
    if (!q) return base;
    return searchQuery(q, base);
  }, [q, role]);

  return (
    <div className="container" style={{ display: "grid", gap: 16 }}>
      <header className="row" style={{ justifyContent: "space-between" }}>
        <h2 style={{ margin: 0 }}>Biblioteca de tutoriales</h2>
        <input value={q} onChange={e => setQ(e.target.value)} placeholder="Buscar…" aria-label="Buscar tutorial" />
      </header>
      <div className="row" style={{ gap: 8 }}>
        {["all","newbie","dev","validator","creator"].map(r => (
          <button key={r} className="button" onClick={() => setRole(r as any)} aria-pressed={role===r}>{r}</button>
        ))}
      </div>
      <ul style={{ listStyle: "none", padding: 0, display: "grid", gap: 12 }}>
        {list.map((t: TutorialMeta) => (
          <li key={t.slug} className="card" style={{ display: "grid", gap: 6 }}>
            <div className="row" style={{ justifyContent: "space-between" }}>
              <strong>{t.title}</strong>
              <span style={{ color: "var(--fg-muted)" }}>{t.duration} min · v{t.version} · revisado {t.lastReviewed}</span>
            </div>
            <div className="row" style={{ gap: 8 }}>
              <span style={{ fontSize: 12, opacity: .8 }}>Perfil: {t.role}</span>
              {(t.tags || []).slice(0,3).map(tag => <span key={tag} style={{ fontSize: 12, opacity: .7 }}>#{tag}</span>)}
            </div>
            <div><Link to={`/learn/tutorial/${t.slug}`} className="button">Abrir</Link></div>
          </li>
        ))}
      </ul>

      <section className="card">
        <h3 style={{ marginTop: 0 }}>Rutas por rol</h3>
        <ul>
          {Object.entries(pathsByRole).map(([r, slugs]) => (
            <li key={r}>
              <strong>{r}</strong>: {slugs.map(s => <Link key={s} to={`/learn/tutorial/${s}`} style={{ marginInline: 6 }}>{s}</Link>)}
            </li>
          ))}
        </ul>
      </section>
    </div>
  );
}

Ruta completa: apps/web/src/modules/learn/pages/TutorialView.tsx
import React, { useEffect } from "react";
import { useParams } from "react-router-dom";
import { getBySlug } from "../catalog";
import { MDXProvider } from "@mdx-js/react";
import * as mdxComponents from "../mdx";
import { ScormProvider, useScorm } from "../scorm/ScormProvider";

function Content({ slug, Mod }: { slug: string; Mod: any }) {
  const { start, finish } = useScorm();
  useEffect(() => { start(); return () => finish(); }, []);
  return (
    <div className="container" style={{ display: "grid", gap: 16 }}>
      <MDXProvider components={{ ...mdxComponents }}>
        <article className="card"><Mod /></article>
      </MDXProvider>
    </div>
  );
}

export default function TutorialView() {
  const { slug = "" } = useParams();
  const found = getBySlug(slug);
  if (!found) return <div className="container">No encontrado</div>;
  const Mod = found.mod.default;
  return (
    <ScormProvider slug={slug}>
      <Content slug={slug} Mod={Mod} />
    </ScormProvider>
  );
}

Ruta completa: apps/web/src/modules/learn/pages/Path.tsx
import React from "react";
import { useParams, Link } from "react-router-dom";
import { pathsByRole } from "../catalog";

export default function Path() {
  const { role = "newbie" } = useParams();
  const slugs = (pathsByRole as any)[role] || [];
  return (
    <div className="container" style={{ display: "grid", gap: 12 }}>
      <h2>Ruta: {role}</h2>
      <ol>{slugs.map((s: string) => <li key={s}><Link to={`/learn/tutorial/${s}`}>{s}</Link></li>)}</ol>
    </div>
  );
}

 
Búsqueda semántica (índice + runtime)
Ruta completa: apps/web/src/modules/learn/search/search.ts
import { TutorialMeta } from "../catalog";
import index from "/apps/web/content/index.json"; // { items: [{ slug, title, role, tags, vec: number[] }, ...] }

function dot(a:number[], b:number[]) { let s=0; for (let i=0;i<Math.min(a.length,b.length);i++) s+=a[i]*b[i]; return s; }
function norm(a:number[]) { return Math.sqrt(dot(a,a)) || 1; }

export function searchQuery(q: string, metas: TutorialMeta[]) {
  // Fallback simple: si no hay index.json, usa filtro por texto.
  if (!index?.items) {
    const ql = q.toLowerCase();
    return metas.filter(m => (m.title+m.slug+(m.tags||[]).join()).toLowerCase().includes(ql));
  }
  const vecQ = (index as any).encode?.(q) || (index as any).qvec || []; // opcional si se inyecta encoder en runtime
  const items: any[] = (index as any).items || [];
  const scores = new Map<string, number>();
  items.forEach(it => {
    const s = dot(vecQ, it.vec) / (norm(vecQ) * norm(it.vec));
    scores.set(it.slug, s);
  });
  return metas.slice().sort((a,b) => (scores.get(b.slug)||0) - (scores.get(a.slug)||0));
}

Ruta completa: tools/build-embedding-index.ts (Node script para generar index.json)
/**
 * Genera embeddings locales (JS/WASM) con @xenova/transformers y guarda index.json.
 * `pnpm tsx tools/build-embedding-index.ts`
 */
import fs from "node:fs/promises";
import matter from "gray-matter";
import path from "node:path";
import { pipeline } from "@xenova/transformers"; // ejecuta en Node con WASM

const root = path.resolve(__dirname, "..", "apps", "web");
const contentDir = path.join(root, "content", "tutorials");

async function embedder() {
  // Modelo pequeño para semántica general
  // @ts-ignore
  return await pipeline("feature-extraction", "Xenova/all-MiniLM-L6-v2");
}

async function run() {
  const files = (await fs.readdir(contentDir)).filter(f => f.endsWith(".mdx"));
  const ef = await embedder();
  const items:any[] = [];
  for (const f of files) {
    const p = path.join(contentDir, f);
    const raw = await fs.readFile(p, "utf8");
    const { content, data } = matter(raw);
    const text = `${data.title}\n${(data.tags||[]).join(" ")}\n${content.replace(/[`*#<>[\]]/g," ")}`;
    const output:any = await ef(text, { pooling: "mean", normalize: true });
    const vec = Array.from(output.data);
    items.push({ slug: data.slug, title: data.title, role: data.role, tags: data.tags||[], vec });
  }
  const out = { model: "all-MiniLM-L6-v2", dim: items[0]?.vec?.length || 384, items };
  await fs.writeFile(path.join(root, "content", "index.json"), JSON.stringify(out));
  console.log(`Index build OK · ${items.length} items`);
}
run().catch(e => { console.error(e); process.exit(1); });

 
Rutas en el router de la app web
Ruta completa: apps/web/src/router/guards.tsx (añade “learn”)
// ...imports previos...
import Library from "@modules/learn/pages/Library";
import TutorialView from "@modules/learn/pages/TutorialView";
import Path from "@modules/learn/pages/Path";

export const router = createBrowserRouter([
  {
    path: "/",
    element: <AppLayout />,
    children: [
      // ...rutas existentes...
      { path: "learn", element: <Library /> },
      { path: "learn/path/:role", element: <Path /> },
      { path: "learn/tutorial/:slug", element: <TutorialView /> }
    ]
  }
]);

 
Contrato opcional (soulbound) + ejemplo minimal
Ruta completa: contracts/SoulboundBadge.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";

/**
 * @title SoulboundBadge
 * @notice ERC721 no transferible (soulbound). Mint controlado por claim() con criterios off-chain.
 */
contract SoulboundBadge extends ERC721, AccessControl {
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    error Soulbound();
    error AlreadyHasBadge();

    mapping(address => mapping(string => bool)) public has; // has[who][badgeId] = true
    uint256 public nextId;

    constructor(address admin) ERC721("GNEW Badges", "GNWB") {
        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(MINTER_ROLE, admin);
    }

    function claim(address to, string memory badgeId, string memory /*slug*/, uint256 /*score*/) external onlyRole(MINTER_ROLE) {
        if (has[to][badgeId]) revert AlreadyHasBadge();
        has[to][badgeId] = true;
        _safeMint(to, ++nextId);
    }

    function _update(address from, address to, uint256 tokenId, address auth) internal override returns (bool) {
        if (from != address(0) && to != address(0)) revert Soulbound();
        return super._update(from, to, tokenId, auth);
    }
}

Nota: en producción, verifica en el backend los criterios (score, slug) y llama a claim desde un relayer con MINTER_ROLE. La UI ya lanza claimSoulbound, pero puedes cambiarla para ir contra API propia y evitar abusos.
 
Docusaurus (docs de aprendizaje y versionado)
Ruta completa: docs/sidebars.js (añade sección “Learning”)
module.exports = {
  docs: [
    // ...otras secciones...
    {
      type: "category",
      label: "Learning",
      items: ["learning/overview", "learning/content-standards", "learning/versioning"]
    }
  ]
};

Ruta completa: docs/learning/versioning.md
# Versionado y “Last reviewed”
- Cada MDX lleva `version` y `lastReviewed` (YYYY-MM-DD).
- Política: contenido clave se revisa **cada 90 días**. Si `lastReviewed` > 90 días, el build avisa.
- Mantener changelog por tutorial si cambia el flujo.

Ruta completa: tools/validate-content.ts (fail si desactualizado)
import fs from "node:fs/promises";
import path from "node:path";
import matter from "gray-matter";

const root = path.resolve(__dirname, "..", "apps", "web", "content", "tutorials");
const MAX_DAYS = 90;

async function run() {
  const files = (await fs.readdir(root)).filter(f => f.endsWith(".mdx"));
  const now = new Date();
  let outdated: string[] = [];
  for (const f of files) {
    const raw = await fs.readFile(path.join(root, f), "utf8");
    const { data } = matter(raw);
    const d = new Date(data.lastReviewed);
    const diff = (now.getTime() - d.getTime()) / (1000 * 3600 * 24);
    if (diff > MAX_DAYS) outdated.push(`${data.slug} (${data.lastReviewed})`);
  }
  if (outdated.length) {
    console.error("❌ Tutoriales desactualizados:", outdated.join(", "));
    process.exit(1);
  } else {
    console.log("✅ Contenido al día");
  }
}
run();

 
Analítica de resultados (DoD de negocio)
●	Eventos (Amplitude):

○	learn_started / learn_finished (con scorePct)

○	learn_quiz_answered

○	learn_badge_claim_attempt / learn_badge_claimed

●	Funnel: Inicio → Finalización (meta tasa ≥ X%).

●	Satisfacción: encuesta in app (1–5) al terminar; evento learn_satisfaction con score (meta ≥ Y/5).

Ruta completa: apps/web/src/modules/learn/pages/Satisfaction.tsx
import React, { useState } from "react";
import { track } from "@lib/analytics";
export default function Satisfaction({ slug }:{ slug: string }) {
  const [s, setS] = useState<number|undefined>();
  if (s) return <div>¡Gracias! {s}/5</div>;
  return (
    <div className="card" aria-label="Encuesta de satisfacción" style={{ marginTop: 12 }}>
      <div>¿Qué te pareció este tutorial?</div>
      <div className="row" style={{ gap: 6 }}>
        {[1,2,3,4,5].map(n => <button key={n} className="button" onClick={() => { setS(n); track("learn_satisfaction", { slug, score: n }); }}>{n}</button>)}
      </div>
    </div>
  );
}

Inserta <Satisfaction slug={slug} /> al final de TutorialView si deseas medir Y/5.
 
CI/CD (checks de contenido y semántica)
