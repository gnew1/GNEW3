repos: 
  - repo: https://github.com/pre-commit/pre-commit-hooks 
    rev: v4.6.0 
    hooks: 
      - id: check-added-large-files 
      - id: check-yaml 
      - id: end-of-file-fixer 
  - repo: https://github.com/zricethezav/gitleaks 
    rev: v8.18.4 
    hooks: 
      - id: gitleaks 
  - repo: local 
    hooks: 
      - id: forbid-latest-tag 
        name: Forbid latest tag in k8s manifests 
        entry: bash -c "grep -R \"image: .*:latest\" -n apps infra || 
(echo OK)" 
        language: system 
        pass_filenames: false 
      - id: lockfiles-present 
        name: Ensure lockfiles present 
        entry: bash -c 'test -f pnpm-lock.yaml || test -f 
package-lock.json || test -f poetry.lock || test -f requirements.txt 
|| (echo "Falta lockfile" && exit 1)' 
        language: system 
        pass_filenames: false 
 
 
8) Documentación de verificación manual 
Ruta completa: docs/security/supply-chain-manual.md 
## Verificar firma (Cosign) 
```bash 
cosign verify ghcr.io/<org>/gnew-gateway@sha256:<digest> \ 
  --certificate-oidc-issuer 
https://token.actions.githubusercontent.com \ 
  --certificate-identity 
"https://github.com/<org>/<repo>/.github/workflows/supply-chain.yml@re
 fs/heads/main" 
 
Ver SBOM adjunta 
cosign verify-attestation --type spdx 
ghcr.io/<org>/gnew-gateway@sha256:<digest> 
 
Ver SLSA (provenance) 
● Si usas el slsa-github-generator, consulta la attestation en el propio registro o en la 
pestaña Attestations de GitHub (si activado). --- 
# 9) Helm: fuerza uso de **digest** y pasa imagenes firmadas 
Ruta completa: infra/helm/gnew-platform/templates/_images.tpl 
```tpl 
{{- define "gnew.image" -}} 
{{- if .digest -}} 
{{ printf "%s@%s" .repository .digest }} 
{{- else -}} 
{{ printf "%s:%s" .repository (.tag | default "latest") }} 
{{- end -}} 
{{- end -}} 
Ruta completa: infra/helm/gnew-platform/values.supplychain.yaml 
supplychain: 
expectedIdentity: 
"https://github.com/GNEW-ORG/GNEW/.github/workflows/supply-chain.yml@r
 efs/heads/main" 
images: 
gateway: 
repository: ghcr.io/gnew-org/gnew-gateway 
digest: "sha256:REPLACE_AT_DEPLOY" # rellenado por pipeline con 
digest exacto 
(El workflow de deploy debe resolver digest y pasar --set 
images.gateway.digest=<sha256> para que el manifiesto siempre reference el digest, no 
tag.) 
10) Snippet utilitario: resolver digest y 
verificar 
Ruta completa: scripts/ci/resolve-and-verify.sh 
#!/usr/bin/env bash 
set -euo pipefail 
IMG="${1:?image:tag}" 
EXPECTED="${2:?expected identity}" 
DIGEST=$(crane digest "$IMG") 
FULL="${IMG%@*}@${DIGEST}" 
echo "Resolved: $FULL" 
cosign verify "$FULL" \ --certificate-oidc-issuer 
"https://token.actions.githubusercontent.com" \ --certificate-identity "$EXPECTED" \ --rekor-url https://rekor.sigstore.dev >/dev/null 
echo "$FULL" 
Cómo cumple el DoD 
● Bloqueo de libs vulnerables: 
○ Grype (imagen) y OSV-Scanner (ecosistemas) con --fail-on High. 
○ Conftest opcional para SBOM enriquecido. 
○ Dependabot mantiene versiones actualizadas. 
● Trazabilidad total: 
○ SBOM (SPDX) generada y anexada como attestation OCI. 
○ SLSA provenance generada para imágenes. 
○ Firmas Cosign (keyless) vinculadas a OIDC identity del workflow. 
● Verificación en despliegue: 
○ Paso de verify en CI y admission control (Kyverno/Sigstore) en el clúster. 
○ Tags inmutables (digests) y prohibición de latest. 
Con estos archivos, GNEW obtiene integridad desde el código al deploy, políticas de 
dependencia estrictas, verificación de artefactos y bloqueo de vulnerabilidades de severidad 
alta, cumpliendo N98. 
Tú dijiste: 
programa a nivel de detalle para GNEW N99 10.9 Estrategias de despliegue (Prompt 99) 
Objetivo: Blue/Green, Canary y feature flags. Roles: DevOps, QA, Producto. Stack: 
ArgoCD/Flux, Flagger, LaunchDarkly/Unleash. Entregables: Pipelines con estrategias 
parametrizadas. DoD: Impacto controlado; rollback en un click. 
ChatGPT Plus 
Pensó durante 1m 58s 
Ruta completa: infra/strategies/README.md 
# GNEW · N99 (10.8) Estrategias de despliegue 
**Objetivo:** Blue/Green, Canary y Feature Flags con **ArgoCD/Flux**, 
**Flagger**, **LaunchDarkly/Unleash**.   
**Entregables:** Pipelines parametrizables por estrategia + manifests 
listos para producción.   
**DoD:** Impacto controlado (métricas y gates), **rollback en un 
click** (ArgoCD), trazabilidad por commit. 
## Estrategias soportadas - **Canary (Flagger + NGINX/Prometheus):** tráfico progresivo 
1%→5%→20%→50%→100% con rollback automático si aumentan 5xx o latencia 
p95. - **Blue/Green (ArgoCD + Kustomize):** dos versiones activas (blue, 
green). “Switch” cambiando el backend del Ingress (un click). - **Feature flags (Unleash/LaunchDarkly):** toggles runtime sin 
redeploy. Flags por entorno y “kill switches”. 
## Requisitos previos - N91 (IaC) desplegado con `ingress-nginx`, Prometheus y Helm. 
- N92 (CI/CD) activo con imágenes en GHCR y despliegue por 
Helm/ArgoCD. - N94 (observabilidad) expose `http_requests_total` y 
`http_request_duration_seconds_*`. 
 
 
1) Flagger (Canary) – instalación e 
integración 
Ruta completa: infra/iac/terraform/k8s/flagger.tf 
terraform { 
  required_providers { 
    helm        = { source = "hashicorp/helm", version = "~> 2.15" } 
    kubernetes  = { source = "hashicorp/kubernetes", version = "~> 
2.31" } 
  } 
} 
variable "kubeconfig_path" { type = string } 
provider "kubernetes" { config_path = var.kubeconfig_path } 
provider "helm" { kubernetes { config_path = var.kubeconfig_path } } 
 
# Flagger (provider NGINX + Prometheus) 
resource "helm_release" "flagger" { 
  name             = "flagger" 
  repository       = "https://flagger.app" 
  chart            = "flagger" 
  version          = "1.35.0" 
  namespace        = "flagger-system" 
  create_namespace = true 
  values = [yamlencode({ 
    metricsServer = 
"http://prometheus-kube-prometheus-prometheus.monitoring:9090" 
    meshProvider  = "kubernetes" 
    # provider ingress-nginx (traffic routing por Ingress anotation) 
    metricsServerTimeout = "10s" 
  })] 
} 
 
# CRDs (si no vienen con el chart) 
resource "kubernetes_manifest" "flagger_crds" { 
  manifest = yamldecode(file("${path.module}/flagger-crds.yaml")) 
  depends_on = [helm_release.flagger] 
} 
 
Si tu chart ya instala CRDs, elimina kubernetes_manifest. 
 
2) Canary por servicio (ejemplo: gateway) 
Ruta completa: apps/gateway/canary/gateway-canary.yaml 
apiVersion: flagger.app/v1beta1 
kind: Canary 
metadata: 
  name: gateway 
  namespace: gnew-system 
spec: 
  # Flagger observa este Deployment y crea un "primary" + services 
"primary/canary" 
  targetRef: 
    apiVersion: apps/v1 
    kind: Deployment 
    name: gateway 
  service: 
    port: 80 
    targetPort: http 
    # Servicios que Flagger gestiona 
    trafficPolicy: 
      tls: false 
  ingressRef: 
    apiVersion: networking.k8s.io/v1 
    kind: Ingress 
    name: gateway-ing 
  analysis: 
    interval: 1m 
    threshold: 10          # nº de chequeos fallidos antes de rollback 
    maxWeight: 50          # peso máximo al que llega el canary 
    stepWeight: 5 
    webhooks: []           # (opcional) tests e2e externos 
(k6/cypress) 
    metrics: 
      - name: "request-success-rate" 
        interval: 1m 
        thresholdRange: 
          min: 99 
        templateRef: 
          name: success-rate 
      - name: "request-duration" 
        interval: 1m 
        thresholdRange: 
          max: 800 
        templateRef: 
          name: latency 
 
Ruta completa: apps/gateway/canary/metric-templates.yaml 
apiVersion: flagger.app/v1beta1 
kind: MetricTemplate 
metadata: 
  name: success-rate 
  namespace: gnew-system 
spec: 
  provider: 
    type: prometheus 
    address: 
http://prometheus-kube-prometheus-prometheus.monitoring:9090 
  query: | 
    100 - 
(sum(rate(http_requests_total{service="gateway",status=~"5.."}[{{ 
interval }}])) / 
sum(rate(http_requests_total{service="gateway"}[{{ interval 
}}])) * 100) --- 
apiVersion: flagger.app/v1beta1 
kind: MetricTemplate 
metadata: 
name: latency 
namespace: gnew-system 
spec: 
provider: 
type: prometheus 
address: 
http://prometheus-kube-prometheus-prometheus.monitoring:9090 
query: | 
histogram_quantile(0.95, 
sum(rate(http_request_duration_seconds_bucket{service="gateway"}[{{ 
interval }}])) by (le)) * 1000 
Flagger creará automáticamente gateway-primary / gateway-canary Services 
y gestionará el Ingress gateway-ing. 
3) Blue/Green con Kustomize + ArgoCD 
Estructura GitOps para Gateway: 
apps/gateway/kustomize/ 
├─ base/ 
│  ├─ deployment-blue.yaml 
│  ├─ deployment-green.yaml 
│  ├─ service-blue.yaml 
│  ├─ service-green.yaml 
│  └─ ingress.yaml        
├─ overlays/ 
│  ├─ prod-blue/ 
# apunta a uno u otro via overlay 
│  │  ├─ kustomization.yaml (patch: ingress -> gateway-blue) 
  │  └─ prod-green/ 
  │     └─ kustomization.yaml (patch: ingress -> gateway-green) 
 
Ruta completa: apps/gateway/kustomize/base/deployment-blue.yaml 
apiVersion: apps/v1 
kind: Deployment 
metadata: 
  name: gateway-blue 
  namespace: gnew-system 
  labels: { app: gateway, color: blue } 
spec: 
  replicas: 3 
  selector: { matchLabels: { app: gateway, color: blue } } 
  template: 
    metadata: { labels: { app: gateway, color: blue } } 
    spec: 
      containers: 
        - name: gateway 
          image: ghcr.io/gnew-org/gnew-gateway:{{TAG}} 
          ports: [{ name: http, containerPort: 8000 }] 
          readinessProbe: { httpGet: { path: /health, port: http }, 
initialDelaySeconds: 10 } 
 
Ruta completa: apps/gateway/kustomize/base/deployment-green.yaml 
apiVersion: apps/v1 
kind: Deployment 
metadata: 
  name: gateway-green 
  namespace: gnew-system 
  labels: { app: gateway, color: green } 
spec: 
  replicas: 3 
  selector: { matchLabels: { app: gateway, color: green } } 
  template: 
    metadata: { labels: { app: gateway, color: green } } 
    spec: 
      containers: 
        - name: gateway 
          image: ghcr.io/gnew-org/gnew-gateway:{{TAG}} 
          ports: [{ name: http, containerPort: 8000 }] 
          readinessProbe: { httpGet: { path: /health, port: http }, 
initialDelaySeconds: 10 } 
 
Ruta completa: apps/gateway/kustomize/base/service-blue.yaml 
apiVersion: v1 
kind: Service 
metadata: 
  name: gateway-blue 
  namespace: gnew-system 
  labels: { app: gateway, color: blue } 
spec: 
  selector: { app: gateway, color: blue } 
  ports: [{ name: http, port: 80, targetPort: http }] 
 
Ruta completa: apps/gateway/kustomize/base/service-green.yaml 
apiVersion: v1 
kind: Service 
metadata: 
  name: gateway-green 
  namespace: gnew-system 
  labels: { app: gateway, color: green } 
spec: 
  selector: { app: gateway, color: green } 
  ports: [{ name: http, port: 80, targetPort: http }] 
 
Ruta completa: apps/gateway/kustomize/base/ingress.yaml 
apiVersion: networking.k8s.io/v1 
kind: Ingress 
metadata: 
  name: gateway-ing 
  namespace: gnew-system 
  annotations: 
    kubernetes.io/ingress.class: "nginx" 
spec: 
  rules: 
    - host: api.gnew.example 
      http: 
        paths: 
          - path: / 
            pathType: Prefix 
            backend: 
              service: 
                # patched in overlay: gateway-blue or gateway-green 
                name: gateway-blue 
                port: { number: 80 } 
 
Ruta completa: apps/gateway/kustomize/overlays/prod-blue/kustomization.yaml 
apiVersion: kustomize.config.k8s.io/v1beta1 
kind: Kustomization 
resources: ["../../base"] 
patches: 
  - target: { kind: Ingress, name: gateway-ing } 
    patch: |- 
      - op: replace 
